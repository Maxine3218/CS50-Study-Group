1
00:00:50,960 --> 00:00:52,840
中文字幕
- --we know?

2
00:00:52,840 --> 00:00:56,660
中文字幕
- That at 9:15, Ray Santoya was at the ATM.

3
00:00:56,660 --> 00:00:59,890
中文字幕
- So the question is, what was he doing at 9:16?

4
00:00:59,890 --> 00:01:02,690
中文字幕
- Shooting the nine-millimeter at something.

5
00:01:02,690 --> 00:01:04,330
中文字幕
Maybe he saw the sniper.

6
00:01:04,330 --> 00:01:06,440
中文字幕
- Or he was working with him.

7
00:01:06,440 --> 00:01:07,680
中文字幕
- Right.

8
00:01:07,680 --> 00:01:08,620
中文字幕
Go back one.

9
00:01:08,620 --> 00:01:09,370
中文字幕
- What do you see?

10
00:01:17,190 --> 00:01:18,310
中文字幕
- Bring his face up.

11
00:01:18,310 --> 00:01:20,900
中文字幕
Full screen.

12
00:01:20,900 --> 00:01:22,020
中文字幕
- His glasses.

13
00:01:22,020 --> 00:01:23,320
中文字幕
- There's a reflection.

14
00:01:33,490 --> 00:01:35,080
中文字幕
- That's Neuvitas baseball team.

15
00:01:35,080 --> 00:01:36,200
中文字幕
That's their logo.

16
00:01:36,200 --> 00:01:39,110
中文字幕
- And he's talking to whoever is wearing that jacket.

17
00:01:39,110 --> 00:01:40,400
中文字幕
- We may have a witness.

18
00:01:40,400 --> 00:01:41,750
中文字幕
- To both shootings.

19
00:01:42,340 --> 00:01:45,910
中文字幕
This is he is CS50, and this is lecture 3, and that

20
00:01:45,910 --> 00:01:47,800
中文字幕
is not how computer science works.

21
00:01:47,800 --> 00:01:49,600
中文字幕
And indeed, by the end of today, we'll make

22
00:01:49,600 --> 00:01:52,270
中文字幕
clear exactly what's right, what's not right about that,

23
00:01:52,270 --> 00:01:57,340
中文字幕
and hopefully give you some pause any time you watch TV or movies hereafter

24
00:01:57,340 --> 00:02:00,160
中文字幕
and notice these little things that all too many writers seem

25
00:02:00,160 --> 00:02:02,390
中文字幕
to take for granted.

26
00:02:02,390 --> 00:02:06,620
中文字幕
So recall that last time, we took a look lower level at what compiling actually

27
00:02:06,620 --> 00:02:07,120
中文字幕
is.

28
00:02:07,120 --> 00:02:10,570
中文字幕
And recall that it was a few things, these four steps of pre-processing

29
00:02:10,570 --> 00:02:12,380
中文字幕
and compiling and assembling and linking,

30
00:02:12,380 --> 00:02:14,260
中文字幕
so that when you start with their source cod,

31
00:02:14,260 --> 00:02:17,140
中文字幕
that might look like this code that we have written in the past,

32
00:02:17,140 --> 00:02:20,590
中文字幕
you first have to preprocess it, and the first step in pre-processing was

33
00:02:20,590 --> 00:02:23,180
中文字幕
converting all of those processor instructions--

34
00:02:23,180 --> 00:02:26,650
中文字幕
anything starting with a hash at the beginning-- to their equivalents.

35
00:02:26,650 --> 00:02:29,530
中文字幕
So opening the files and effectively copying and pasting the contents

36
00:02:29,530 --> 00:02:32,680
中文字幕
there so that programs and the compiler know what get_string

37
00:02:32,680 --> 00:02:34,330
中文字幕
is and know what printf is.

38
00:02:34,330 --> 00:02:36,400
中文字幕
The next step that came after that was actually

39
00:02:36,400 --> 00:02:39,820
中文字幕
compiling, whereby compiling technically means taking that source

40
00:02:39,820 --> 00:02:42,790
中文字幕
code, once it's been preprocessed, and printing and generating

41
00:02:42,790 --> 00:02:45,710
中文字幕
this very cryptic-looking stuff called assembly code.

42
00:02:45,710 --> 00:02:50,140
中文字幕
And those assembly codes or assembly instructions are really what the CPU--

43
00:02:50,140 --> 00:02:52,780
中文字幕
the brain of your computer-- actually understands,

44
00:02:52,780 --> 00:02:55,840
中文字幕
although technically the computer understands them only in the form

45
00:02:55,840 --> 00:02:57,170
中文字幕
of 0's and 1's.

46
00:02:57,170 --> 00:03:00,010
中文字幕
And so when you "assemble-- step three--

47
00:03:00,010 --> 00:03:02,950
中文字幕
that assembly code, you actually get out those 0's and 1's.

48
00:03:02,950 --> 00:03:06,160
中文字幕
But even that simplest of programs where we just prompt the user for a string

49
00:03:06,160 --> 00:03:10,010
中文字幕
and then print out their name still involved a couple more files.

50
00:03:10,010 --> 00:03:15,730
中文字幕
There was not only cs50.h and stdio.h at the top,

51
00:03:15,730 --> 00:03:20,650
中文字幕
somewhere in the computer system there's probably files called cs50.c,

52
00:03:20,650 --> 00:03:25,060
中文字幕
and in the case of stdio, printf.c, in which actually the code is

53
00:03:25,060 --> 00:03:28,300
中文字幕
for those two functions, those two have to get compiled down

54
00:03:28,300 --> 00:03:31,690
中文字幕
to 0's and 1's, and then we need to link everything together,

55
00:03:31,690 --> 00:03:35,140
中文字幕
merging those 0's and 1's so that the computer has access to your code

56
00:03:35,140 --> 00:03:39,020
中文字幕
and to printf's code and to the cs50 library's code And so forth.

57
00:03:39,020 --> 00:03:43,420
中文字幕
But all of that we can just generally wrap up in the descriptor of compiling.

58
00:03:43,420 --> 00:03:45,520
中文字幕
And so that's one of the looks we took last week.

59
00:03:45,520 --> 00:03:49,090
中文字幕
And we also have introduced, last week and previously, a few tools.

60
00:03:49,090 --> 00:03:52,420
中文字幕
And odds are, you're having as many frustrations perhaps already

61
00:03:52,420 --> 00:03:54,660
中文字幕
with the p-sets as you are accomplishments

62
00:03:54,660 --> 00:03:55,750
中文字幕
and sense of satisfaction.

63
00:03:55,750 --> 00:03:59,440
中文字幕
And that's normal, and rest assured that the scales will eventually tip more

64
00:03:59,440 --> 00:04:01,900
中文字幕
toward happiness and away from sadness, but we'll

65
00:04:01,900 --> 00:04:05,260
中文字幕
give you indeed more tools today than these for actually finding

66
00:04:05,260 --> 00:04:07,750
中文字幕
problems or shortcomings in your code.

67
00:04:07,750 --> 00:04:10,690
中文字幕
help50, recall, helps you with what process?

68
00:04:10,690 --> 00:04:14,130
中文字幕
When you instinctively consider using help50?

69
00:04:14,130 --> 00:04:15,880
中文字幕
When you see error messages on the screen.

70
00:04:15,880 --> 00:04:18,370
中文字幕
Something you don't understand that's the result of some mistake you

71
00:04:18,370 --> 00:04:21,410
中文字幕
probably made but you don't quite understand what the computer is telling

72
00:04:21,410 --> 00:04:24,520
中文字幕
you, run help50, and then that same command and we, the staff,

73
00:04:24,520 --> 00:04:26,860
中文字幕
with our code will try to understand the message for you

74
00:04:26,860 --> 00:04:28,390
中文字幕
and provide you with feedback.

75
00:04:28,390 --> 00:04:30,500
中文字幕
style50 does exactly that.

76
00:04:30,500 --> 00:04:34,440
中文字幕
It helps you see with red and green color coding exactly what spaces should

77
00:04:34,440 --> 00:04:36,740
中文字幕
be there, shouldn't be there-- it just helps you pretty

78
00:04:36,740 --> 00:04:39,920
中文字幕
your code so that you can read it better and other humans can as well.

79
00:04:39,920 --> 00:04:44,440
中文字幕
And then printf, which is kind of like the coarsest tool in your tool box,

80
00:04:44,440 --> 00:04:47,980
中文字幕
this is just helping you see not only messages you want to see,

81
00:04:47,980 --> 00:04:49,350
中文字幕
but just the values of variables.

82
00:04:49,350 --> 00:04:51,440
中文字幕
You can print ints and strings, whatever you want,

83
00:04:51,440 --> 00:04:54,080
中文字幕
and then you can delete those lines of printf

84
00:04:54,080 --> 00:04:55,960
中文字幕
once you're confident your program's working.

85
00:04:55,960 --> 00:04:59,000
中文字幕
But that gets a little tedious, and honestly, as our programs get bigger,

86
00:04:59,000 --> 00:05:02,140
中文字幕
we're going to want more powerful tools than like manually printing things

87
00:05:02,140 --> 00:05:04,700
中文字幕
out, recompiling, rerunning, it very quickly it gets tedious.

88
00:05:04,700 --> 00:05:07,660
中文字幕
And the goal of programming is not to be tedious, but to be empowering,

89
00:05:07,660 --> 00:05:10,840
中文字幕
and that's where we'll step to today via this.

90
00:05:10,840 --> 00:05:14,920
中文字幕
So CS50 IDE is sort of fancier version of what

91
00:05:14,920 --> 00:05:18,910
中文字幕
you've been using called CS50 Sandbox, and in turn, CS50 Lab.

92
00:05:18,910 --> 00:05:21,550
中文字幕
Now recall that both of those tools, the Sandbox and the Lab,

93
00:05:21,550 --> 00:05:23,680
中文字幕
have a terminal window where you can type commands,

94
00:05:23,680 --> 00:05:29,240
中文字幕
they have a code editor where you can actually write your code,

95
00:05:29,240 --> 00:05:31,450
中文字幕
and then they have a file browser with icons and such

96
00:05:31,450 --> 00:05:34,100
中文字幕
where you can actually see your files and folders.

97
00:05:34,100 --> 00:05:38,410
中文字幕
So it turns out that CS50 IDE is another tool that at first glance

98
00:05:38,410 --> 00:05:41,740
中文字幕
is very, very similar, even though it's laid out a little differently,

99
00:05:41,740 --> 00:05:45,820
中文字幕
but it has as many features as the Sandbox and the Lab, but some more.

100
00:05:45,820 --> 00:05:49,630
中文字幕
More features that actually help you solve problems in your code

101
00:05:49,630 --> 00:05:53,010
中文字幕
and even collaborate come final project time with others if you would like.

102
00:05:53,010 --> 00:05:54,760
中文字幕
So this we'll see is this is the CS50 IDE.

103
00:05:54,760 --> 00:05:56,110
中文字幕
It comes with the so-called night mode so you

104
00:05:56,110 --> 00:05:58,540
中文字幕
can make everything a little darker on your screen, especially if p-setting

105
00:05:58,540 --> 00:06:00,670
中文字幕
at night, and let's actually take a look then

106
00:06:00,670 --> 00:06:04,150
中文字幕
at what you can do with this kind of tool.

107
00:06:04,150 --> 00:06:08,520
中文字幕
When you log into this tool for the very first time in the next problem set,

108
00:06:08,520 --> 00:06:10,900
中文字幕
you'll see an interface that's almost the same as before.

109
00:06:10,900 --> 00:06:13,210
中文字幕
The colors are a little different, the font sizes are a little different,

110
00:06:13,210 --> 00:06:16,100
中文字幕
but at the bottom by default, you have your so-called terminal window,

111
00:06:16,100 --> 00:06:17,980
中文字幕
though instead of the dollar sign now, you'll

112
00:06:17,980 --> 00:06:21,440
中文字幕
see a little more detailed workspace, but more on that in a bit.

113
00:06:21,440 --> 00:06:23,650
中文字幕
Up here you just have the code editor window,

114
00:06:23,650 --> 00:06:25,590
中文字幕
nothing's really going on there.

115
00:06:25,590 --> 00:06:27,640
中文字幕
And then we have the added feature of Ceiling Cat

116
00:06:27,640 --> 00:06:29,390
中文字幕
in the top right-hand corner.

117
00:06:29,390 --> 00:06:31,760
中文字幕
And we'll also see some other features along the way.

118
00:06:31,760 --> 00:06:35,250
中文字幕
So let's actually write a program in CS50 IDE, which, to be clear,

119
00:06:35,250 --> 00:06:39,390
中文字幕
is just another web-based programming environment that also gives you

120
00:06:39,390 --> 00:06:42,600
中文字幕
access to your own cloud-based server.

121
00:06:42,600 --> 00:06:45,990
中文字幕
It, too, is running Ubuntu Linux, which is a popular operating system that

122
00:06:45,990 --> 00:06:47,970
中文字幕
is not macOS and it's not Windows.

123
00:06:47,970 --> 00:06:51,420
中文字幕
But unlike the sandbox environment where you don't even log in

124
00:06:51,420 --> 00:06:53,310
中文字幕
and you lose your files eventually, as you

125
00:06:53,310 --> 00:06:56,010
中文字幕
may know from when your cookies are lost or something goes wrong,

126
00:06:56,010 --> 00:06:57,200
中文字幕
the IDE saves everything.

127
00:06:57,200 --> 00:06:59,250
中文字幕
And you'll log in with your account, and whatever

128
00:06:59,250 --> 00:07:02,130
中文字幕
you put there last week is going to be there this week and next week

129
00:07:02,130 --> 00:07:03,040
中文字幕
and beyond.

130
00:07:03,040 --> 00:07:07,230
中文字幕
So let me go ahead up to File, New File, or I could just click this little plus

131
00:07:07,230 --> 00:07:10,650
中文字幕
icon in the top right-hand corner, and let me go ahead and preemptively hit

132
00:07:10,650 --> 00:07:13,300
中文字幕
Control-S or Command-S or go to File, Save--

133
00:07:13,300 --> 00:07:17,110
中文字幕
you should find the interface very similar to any Mac or PC program--

134
00:07:17,110 --> 00:07:20,380
中文字幕
and let me go ahead and save this file as follows.

135
00:07:20,380 --> 00:07:23,030
中文字幕
I'm going to call this hello.c.

136
00:07:23,030 --> 00:07:25,080
中文字幕
And it's important to mention the file extension,

137
00:07:25,080 --> 00:07:27,510
中文字幕
otherwise the IDE, like the Sandbox and the Lab,

138
00:07:27,510 --> 00:07:29,560
中文字幕
won't know what type of program you're writing.

139
00:07:29,560 --> 00:07:32,230
中文字幕
And then let me go ahead and just write my simplest of programs.

140
00:07:32,230 --> 00:07:37,770
中文字幕
So let me go ahead and include stdio.h, int main void.

141
00:07:37,770 --> 00:07:40,920
中文字幕
Let me go ahead and open my curly braces, printf--

142
00:07:40,920 --> 00:07:43,890
中文字幕
hello, world, backslash n, and a semi-colon.

143
00:07:43,890 --> 00:07:46,060
中文字幕
So you'll notice that almost everything is the same.

144
00:07:46,060 --> 00:07:48,270
中文字幕
The colors are a little different, perhaps,

145
00:07:48,270 --> 00:07:50,200
中文字幕
and you might see some different assistive

146
00:07:50,200 --> 00:07:53,040
中文字幕
features as you're typing your code, but the end result is the same.

147
00:07:53,040 --> 00:07:55,560
中文字幕
And the color coding you just get for free because it's helping

148
00:07:55,560 --> 00:07:57,760
中文字幕
draw your attention to different parts of the code.

149
00:07:57,760 --> 00:07:59,510
中文字幕
Let me go ahead now and--

150
00:07:59,510 --> 00:08:00,460
中文字幕
oh notice this.

151
00:08:00,460 --> 00:08:01,740
中文字幕
There's one difference.

152
00:08:01,740 --> 00:08:05,170
中文字幕
The IDE is a more powerful tool, but as such, it's a more manual tool

153
00:08:05,170 --> 00:08:07,470
中文字幕
and it's not just going to auto-save your code for you.

154
00:08:07,470 --> 00:08:10,170
中文字幕
Nice as that's been with the Sandbox, such that you'd never

155
00:08:10,170 --> 00:08:12,270
中文字幕
actually had the hit Command-S or Control-S--

156
00:08:12,270 --> 00:08:14,870
中文字幕
and if you were, you didn't need to be, the IDE

157
00:08:14,870 --> 00:08:18,570
中文字幕
is only going to save things when you want it to so that nothing

158
00:08:18,570 --> 00:08:20,740
中文字幕
will happen magically anymore.

159
00:08:20,740 --> 00:08:24,570
中文字幕
So what I'm going to have to do is go back up here, File, Save, or Command-S

160
00:08:24,570 --> 00:08:26,460
中文字幕
or Control-S, you'll see a little green dot

161
00:08:26,460 --> 00:08:29,070
中文字幕
briefly, and now and back at my prompt.

162
00:08:29,070 --> 00:08:33,750
中文字幕
I'm going to go ahead now and type my familiar command, make hello, Enter,

163
00:08:33,750 --> 00:08:36,270
中文字幕
and you'll see pretty much the same cryptic-looking client

164
00:08:36,270 --> 00:08:40,950
中文字幕
command as before because the IDE is configured quite like the Sandbox.

165
00:08:40,950 --> 00:08:44,190
中文字幕
And if I want to go ahead and run this now, how do I run this program?

166
00:08:44,190 --> 00:08:46,150
中文字幕
Quick check?

167
00:08:46,150 --> 00:08:48,710
中文字幕
./hello, it's exactly the same as before.

168
00:08:48,710 --> 00:08:51,680
中文字幕
./hello, and there we have it, hello, world.

169
00:08:51,680 --> 00:08:54,830
中文字幕
So long story short, the user interface thus far is a little different,

170
00:08:54,830 --> 00:08:56,220
中文字幕
but functionally it's the same.

171
00:08:56,220 --> 00:08:58,560
中文字幕
We're just going to now start to see some more features.

172
00:08:58,560 --> 00:08:59,510
中文字幕
So what are those features?

173
00:08:59,510 --> 00:09:02,060
中文字幕
And let's introduce new some capabilities that were actually

174
00:09:02,060 --> 00:09:05,760
中文字幕
possible in the Sandbox, we just didn't really introduce them at the time.

175
00:09:05,760 --> 00:09:09,710
中文字幕
If I click this folder icon at top left, you'll see all of my files and folders.

176
00:09:09,710 --> 00:09:12,010
中文字幕
And today for lecture I have a lot of pre-made examples

177
00:09:12,010 --> 00:09:14,930
中文字幕
that are already on the course's website, some of which we'll look at,

178
00:09:14,930 --> 00:09:16,850
中文字幕
some of which we'll refer to the website,

179
00:09:16,850 --> 00:09:18,870
中文字幕
but these are just familiar files and folders.

180
00:09:18,870 --> 00:09:21,410
中文字幕
And you can see that everything in my account

181
00:09:21,410 --> 00:09:23,720
中文字幕
is apparently in something called Workspace, which

182
00:09:23,720 --> 00:09:26,180
中文字幕
is just a folder, name, or a directory.

183
00:09:26,180 --> 00:09:28,190
中文字幕
Here's my sc3 directory, which again, comes

184
00:09:28,190 --> 00:09:30,980
中文字幕
from the website for today's lecture, lecture 3.

185
00:09:30,980 --> 00:09:33,960
中文字幕
And then here's the file I just compiled in the program and the file

186
00:09:33,960 --> 00:09:35,650
中文字幕
that I wrote, hello.c.

187
00:09:35,650 --> 00:09:38,660
中文字幕
You'll notice too that there's this funky symbol here, tilde,

188
00:09:38,660 --> 00:09:41,120
中文字幕
that you might not have occasion to write often in English,

189
00:09:41,120 --> 00:09:44,010
中文字幕
but in Spanish in other languages you might use this character.

190
00:09:44,010 --> 00:09:48,600
中文字幕
This is actually a shorthand notation for what's called your home directory.

191
00:09:48,600 --> 00:09:52,190
中文字幕
In this environment, CS50 IDE, you have your own home directory, which

192
00:09:52,190 --> 00:09:55,880
中文字幕
means your folder of files and other folders that you get to create,

193
00:09:55,880 --> 00:09:59,210
中文字幕
you own, and that persists every time you log in-- you're not

194
00:09:59,210 --> 00:10:00,920
中文字幕
going to lose the contents therein.

195
00:10:00,920 --> 00:10:05,660
中文字幕
So this just means that in your home directory, a.k.a. tilde,

196
00:10:05,660 --> 00:10:09,210
中文字幕
there is a folder called workspace in which I'm currently working.

197
00:10:09,210 --> 00:10:12,170
中文字幕
And that's just one folder in which all of my work is going to be done,

198
00:10:12,170 --> 00:10:15,610
中文字幕
because there's so many other files and folders in this cloud environment,

199
00:10:15,610 --> 00:10:17,990
中文字幕
just like there are in your Mac and PC, we just generally

200
00:10:17,990 --> 00:10:19,430
中文字幕
don't care what they are.

201
00:10:19,430 --> 00:10:25,520
中文字幕
But notice what we can do at this terminal window besides compile

202
00:10:25,520 --> 00:10:26,600
中文字幕
and run code.

203
00:10:26,600 --> 00:10:27,740
中文字幕
There are other commands.

204
00:10:27,740 --> 00:10:33,650
中文字幕
For instance, this blue text here, similarly to the file browser up top,

205
00:10:33,650 --> 00:10:37,260
中文字幕
indicates now not just that this is my prompt per the dollar sign,

206
00:10:37,260 --> 00:10:40,790
中文字幕
but that in my home directory's workspace directory.

207
00:10:40,790 --> 00:10:44,660
中文字幕
So that means I can be elsewhere even though I haven't

208
00:10:44,660 --> 00:10:46,040
中文字幕
specified where I want to go yet.

209
00:10:46,040 --> 00:10:49,460
中文字幕
And in fact, I can do this. ls stands for list,

210
00:10:49,460 --> 00:10:51,270
中文字幕
it's just shorthand notation for that.

211
00:10:51,270 --> 00:10:56,450
中文字幕
And now I see a textual version of my file tree, so to speak.

212
00:10:56,450 --> 00:10:59,340
中文字幕
So you'll see here, sc3 is a folder, and you

213
00:10:59,340 --> 00:11:01,760
中文字幕
can tell as much because there's a slash at the end of it.

214
00:11:01,760 --> 00:11:04,500
中文字幕
hello.c is of course the file I wrote a moment ago.

215
00:11:04,500 --> 00:11:08,750
中文字幕
And then hello in green is my program that I compiled, and the star

216
00:11:08,750 --> 00:11:10,270
中文字幕
or asterisk there is just--

217
00:11:10,270 --> 00:11:12,650
中文字幕
it's not the name of the file, it's just indicating to me

218
00:11:12,650 --> 00:11:14,390
中文字幕
visually that that is executable.

219
00:11:14,390 --> 00:11:17,510
中文字幕
That's a program I can run just so I know what's compiled

220
00:11:17,510 --> 00:11:19,190
中文字幕
and what maybe is source code.

221
00:11:19,190 --> 00:11:23,120
中文字幕
So when you're running ./hello, the reason all this time this has been

222
00:11:23,120 --> 00:11:28,670
中文字幕
working is because in dot, your current folder, there is a file called hello,

223
00:11:28,670 --> 00:11:32,160
中文字幕
and when you hit Enter, you are running that program there.

224
00:11:32,160 --> 00:11:36,470
中文字幕
So if after today you go back onto CS50 Sandbox or CS50 Lab and type ls,

225
00:11:36,470 --> 00:11:39,560
中文字幕
you'll see exactly the same thing as you might by the little folder

226
00:11:39,560 --> 00:11:41,840
中文字幕
icon in those programs as well.

227
00:11:41,840 --> 00:11:44,660
中文字幕
But suppose I want to go into a directory.

228
00:11:44,660 --> 00:11:48,200
中文字幕
In macOS or Windows or even the IDE, I could, of course,

229
00:11:48,200 --> 00:11:51,080
中文字幕
go my File icon, and then per the little triangle

230
00:11:51,080 --> 00:11:53,390
中文字幕
here, which might seem intuitive, you just click it

231
00:11:53,390 --> 00:11:56,150
中文字幕
and you can see what's going on inside, not surprising.

232
00:11:56,150 --> 00:11:57,740
中文字幕
But how do you do that textually?

233
00:11:57,740 --> 00:12:00,270
中文字幕
At a command prompt, well it's not all that hard.

234
00:12:00,270 --> 00:12:02,160
中文字幕
You just need to change your directory.

235
00:12:02,160 --> 00:12:08,670
中文字幕
So if I do cd space sc3, Enter, nothing seems to happen quite yet

236
00:12:08,670 --> 00:12:10,790
中文字幕
except that my prompt changed.

237
00:12:10,790 --> 00:12:13,670
中文字幕
Here's the indication that-- this is my prompt, but to the left of it

238
00:12:13,670 --> 00:12:17,540
中文字幕
you see in blue that I'm now in my home directory's workspace folder,

239
00:12:17,540 --> 00:12:19,990
中文字幕
in my sc3 folder there.

240
00:12:19,990 --> 00:12:23,410
中文字幕
So it's just a text-based version of the GUIs, the Graphical User Interfaces

241
00:12:23,410 --> 00:12:25,160
中文字幕
that all of us have certainly come to take

242
00:12:25,160 --> 00:12:29,010
中文字幕
for granted in the world of macOS and Windows thus far.

243
00:12:29,010 --> 00:12:33,410
中文字幕
Well, suppose that I'm a little done with my hello program

244
00:12:33,410 --> 00:12:34,430
中文字幕
and I want to delete it.

245
00:12:34,430 --> 00:12:37,920
中文字幕
Well in the IDE, like in the Sandbox, you can actually go up here and you can

246
00:12:37,920 --> 00:12:41,030
中文字幕
click on it, and then you can typically right-click or control-click,

247
00:12:41,030 --> 00:12:44,000
中文字幕
and you'll get a whole menu of other options, one of which is Delete--

248
00:12:44,000 --> 00:12:46,590
中文字幕
and feel free to tinker like that in your own environment.

249
00:12:46,590 --> 00:12:48,020
中文字幕
But what about the command line?

250
00:12:48,020 --> 00:12:52,390
中文字幕
If I zoom in down here and I want to remove hello, you're

251
00:12:52,390 --> 00:12:55,100
中文字幕
not going to type remove because that just feels a little verbose

252
00:12:55,100 --> 00:12:58,250
中文字幕
and humans decades ago decided that's too tedious to type,

253
00:12:58,250 --> 00:13:00,410
中文字幕
let's just call this command rm--

254
00:13:00,410 --> 00:13:04,920
中文字幕
for remove-- hello, you're going to see a somewhat cryptic prompt.

255
00:13:04,920 --> 00:13:07,040
中文字幕
rm-- remove regular file 'hello?'

256
00:13:07,040 --> 00:13:09,830
中文字幕
This is more arcane than it needs to be, but it's just asking,

257
00:13:09,830 --> 00:13:11,590
中文字幕
are you sure you want to delete 'hello?'

258
00:13:11,590 --> 00:13:12,950
中文字幕
Then it's just waiting for you.

259
00:13:12,950 --> 00:13:18,050
中文字幕
And here you can type y or yes or sometimes other commands too,

260
00:13:18,050 --> 00:13:20,420
中文字幕
now I've confirmed that my intentions were yes.

261
00:13:20,420 --> 00:13:23,600
中文字幕
If I type ls again, I-- whoops, in the wrong folder.

262
00:13:23,600 --> 00:13:27,810
中文字幕
If I type ls again after doing hello--

263
00:13:27,810 --> 00:13:31,940
中文字幕
no-- after doing hello and do ls, now I'll

264
00:13:31,940 --> 00:13:34,580
中文字幕
see just those two things-- sc3 and hello.c.

265
00:13:34,580 --> 00:13:36,440
中文字幕
What if I want to make a folder?

266
00:13:36,440 --> 00:13:37,340
中文字幕
Well notice this.

267
00:13:37,340 --> 00:13:41,080
中文字幕
If I type at the bottom here, make directory--

268
00:13:41,080 --> 00:13:45,050
中文字幕
mkdir-- test just to make a test folder, I'm

269
00:13:45,050 --> 00:13:48,170
中文字幕
about to hit Enter, but watch the top left-hand corner

270
00:13:48,170 --> 00:13:51,680
中文字幕
where I currently have those other files and folders, and when I hit Enter,

271
00:13:51,680 --> 00:13:53,040
中文字幕
now I have a test folder.

272
00:13:53,040 --> 00:13:54,290
中文字幕
So these things are identical.

273
00:13:54,290 --> 00:13:57,440
中文字幕
One is graphical, one is command line, and there's even other commands

274
00:13:57,440 --> 00:13:59,060
中文字幕
if I decide I don't want that.

275
00:13:59,060 --> 00:14:02,210
中文字幕
rmdir is remove directory, and it just goes away

276
00:14:02,210 --> 00:14:04,590
中文字幕
because it's empty and thus safe.

277
00:14:04,590 --> 00:14:06,680
中文字幕
Any questions then on any of those commands

278
00:14:06,680 --> 00:14:11,500
中文字幕
or just the overall layout of what it is we're looking at?

279
00:14:11,500 --> 00:14:13,880
中文字幕
All right, so don't get hung up on any of those commands,

280
00:14:13,880 --> 00:14:15,200
中文字幕
and the problem set and beyond will always

281
00:14:15,200 --> 00:14:16,670
中文字幕
remind you of those kinds of features.

282
00:14:16,670 --> 00:14:19,460
中文字幕
The point for now is just that we're in a somewhat new environment,

283
00:14:19,460 --> 00:14:23,280
中文字幕
but it's fundamentally still the same, it has the same capabilities.

284
00:14:23,280 --> 00:14:24,830
中文字幕
So what are other tools we looked at?

285
00:14:24,830 --> 00:14:28,550
中文字幕
So you might have heard rumors about a tool called check50, and indeed,

286
00:14:28,550 --> 00:14:31,970
中文字幕
this is a tool that the staff use to evaluate problem set 1 and problems set

287
00:14:31,970 --> 00:14:35,450
中文字幕
2 to evaluate the correctness of them so that we ourselves don't have to type

288
00:14:35,450 --> 00:14:41,660
中文字幕
./mario or ./caesar again and again and again to test students' code.

289
00:14:41,660 --> 00:14:44,640
中文字幕
But starting this week, you, too, have access to the same program.

290
00:14:44,640 --> 00:14:48,440
中文字幕
check50 is a command from the staff that checks the correctness of your code

291
00:14:48,440 --> 00:14:51,800
中文字幕
just like style50 checks the style of your code.

292
00:14:51,800 --> 00:14:53,990
中文字幕
And in fact, if I go back over to my IDE,

293
00:14:53,990 --> 00:14:57,440
中文字幕
let's try to use this for the first time by making the same version of hello

294
00:14:57,440 --> 00:15:00,090
中文字幕
that you did perhaps for your first problem set.

295
00:15:00,090 --> 00:15:04,400
中文字幕
So if I go ahead and include not just stdio, but cs50.h,

296
00:15:04,400 --> 00:15:07,010
中文字幕
and I go ahead and get a string from the user

297
00:15:07,010 --> 00:15:10,280
中文字幕
with get_string, prompting them for their name, and then go ahead

298
00:15:10,280 --> 00:15:14,990
中文字幕
and print not just hello, world, but hello, percent s comma name,

299
00:15:14,990 --> 00:15:17,960
中文字幕
this I believe was the same program you yourselves probably

300
00:15:17,960 --> 00:15:20,010
中文字幕
wrote, or some variant thereof.

301
00:15:20,010 --> 00:15:22,190
中文字幕
So if I go ahead now and test this myself--

302
00:15:22,190 --> 00:15:26,150
中文字幕
make hello, Enter, seems OK, ./hello.

303
00:15:26,150 --> 00:15:29,000
中文字幕
I'm going to go ahead and type in my name, and voila, hello, David.

304
00:15:29,000 --> 00:15:30,920
中文字幕
Now suppose you're feeling pretty good, you're

305
00:15:30,920 --> 00:15:32,710
中文字幕
pretty confident that your code is correct,

306
00:15:32,710 --> 00:15:36,080
中文字幕
and most importantly, you have tested your code yourselves.

307
00:15:36,080 --> 00:15:38,780
中文字幕
It's not sufficient to rely on our tool alone

308
00:15:38,780 --> 00:15:41,540
中文字幕
to test your code because it, too, might not be exhaustive.

309
00:15:41,540 --> 00:15:45,310
中文字幕
So once you've tried a few inputs, not just David, but perhaps

310
00:15:45,310 --> 00:15:47,570
中文字幕
Veronica's name as well, seems to work.

311
00:15:47,570 --> 00:15:49,940
中文字幕
Brian's name as well, seems to work.

312
00:15:49,940 --> 00:15:52,700
中文字幕
No name at all, doesn't seem to work, maybe?

313
00:15:52,700 --> 00:15:54,620
中文字幕
But we'll have to look back to the problem set

314
00:15:54,620 --> 00:15:56,420
中文字幕
to see if that's actually a problem.

315
00:15:56,420 --> 00:15:58,640
中文字幕
Let me go ahead now and run check50.

316
00:15:58,640 --> 00:16:02,330
中文字幕
check50 expects a special slug, so to speak.

317
00:16:02,330 --> 00:16:05,330
中文字幕
Just a unique identifier for the problem that you want to check.

318
00:16:05,330 --> 00:16:07,460
中文字幕
And you would only know this from reading a problem

319
00:16:07,460 --> 00:16:09,080
中文字幕
set or a documentation online.

320
00:16:09,080 --> 00:16:12,080
中文字幕
I just happened to recall that the command that the staff had been using

321
00:16:12,080 --> 00:16:18,280
中文字幕
to grade and evaluate hello is just cs50/2018/fall/hello.

322
00:16:18,280 --> 00:16:21,030
中文字幕
And the slash is to just kind of visually distinguish those words,

323
00:16:21,030 --> 00:16:24,560
中文字幕
this isn't a folder or files or anything like that in your own account.

324
00:16:24,560 --> 00:16:29,030
中文字幕
So I'm going to run check50 cs50/2018/fall/hello in the same

325
00:16:29,030 --> 00:16:31,550
中文字幕
directory that hello.c is in.

326
00:16:31,550 --> 00:16:32,700
中文字幕
Enter.

327
00:16:32,700 --> 00:16:35,740
中文字幕
It's going to go ahead and connect to GitHub, which is the backend,

328
00:16:35,740 --> 00:16:37,490
中文字幕
recall, that we use for storing your code.

329
00:16:37,490 --> 00:16:40,800
中文字幕
It's authenticating me now, which means what's your username and password?

330
00:16:40,800 --> 00:16:43,850
中文字幕
I'm going to go ahead and use one of my test accounts.

331
00:16:43,850 --> 00:16:45,630
中文字幕
And now it's prompting me for my password,

332
00:16:45,630 --> 00:16:47,360
中文字幕
and I'm going to go ahead and type that in.

333
00:16:47,360 --> 00:16:49,970
中文字幕
You'll notice you're seeing stars like you see bullets in a website

334
00:16:49,970 --> 00:16:52,950
中文字幕
just so that someone looking over your shoulder can't see what you're typing.

335
00:16:52,950 --> 00:16:55,190
中文字幕
Now I'm going to go ahead and watch the progress.

336
00:16:55,190 --> 00:16:58,490
中文字幕
It's preparing, let me go ahead and zoom in.

337
00:16:58,490 --> 00:16:59,890
中文字幕
Dot-dot-dot.

338
00:16:59,890 --> 00:17:03,050
中文字幕
It's looking at my code, it's getting ready for submission,

339
00:17:03,050 --> 00:17:07,460
中文字幕
it's now uploading it to GitHub.com, and once it's on the servers,

340
00:17:07,460 --> 00:17:11,150
中文字幕
then it's going to tell CS50 server, here is so-and-so's submission,

341
00:17:11,150 --> 00:17:14,350
中文字幕
go ahead and run a few automated tests on it,

342
00:17:14,350 --> 00:17:17,960
中文字幕
checking therefore its correctness, and hopefully we're about to see some

343
00:17:17,960 --> 00:17:21,200
中文字幕
green, happy smiley faces, and voila, yes,

344
00:17:21,200 --> 00:17:24,100
中文字幕
it looks like this check50 command for this problem--

345
00:17:24,100 --> 00:17:26,150
中文字幕
or slug, so to speak--

346
00:17:26,150 --> 00:17:29,630
中文字幕
checked that hello.c exists, because if I forgot to write the file

347
00:17:29,630 --> 00:17:32,020
中文字幕
or if I misnamed it, nothing's going to work.

348
00:17:32,020 --> 00:17:33,860
中文字幕
We checked that it compiles successfully,

349
00:17:33,860 --> 00:17:35,630
中文字幕
so that, too, is a happy green face.

350
00:17:35,630 --> 00:17:37,070
中文字幕
Then it apparently checked--

351
00:17:37,070 --> 00:17:38,840
中文字幕
what if we type in Veronica?

352
00:17:38,840 --> 00:17:40,250
中文字幕
Do we see hello, Veronica?

353
00:17:40,250 --> 00:17:41,030
中文字幕
Apparently yes.

354
00:17:41,030 --> 00:17:42,800
中文字幕
What if we typed in another word, Brian?

355
00:17:42,800 --> 00:17:44,480
中文字幕
Yes, apparently we say hello, Brian.

356
00:17:44,480 --> 00:17:46,190
中文字幕
And so with high probability, we're going

357
00:17:46,190 --> 00:17:49,920
中文字幕
to conclude, based on those four tests, that your code is, in fact, correct,

358
00:17:49,920 --> 00:17:51,810
中文字幕
at least with respect to those inputs.

359
00:17:51,810 --> 00:17:54,300
中文字幕
And there's often some more detail via URL at the bottom

360
00:17:54,300 --> 00:17:56,510
中文字幕
where you can actually see more graphically just more

361
00:17:56,510 --> 00:17:57,740
中文字幕
feedback on your code.

362
00:17:57,740 --> 00:18:01,490
中文字幕
Of course, the first time, second time, third time maybe you run this command,

363
00:18:01,490 --> 00:18:03,410
中文字幕
you might not see some green happy faces,

364
00:18:03,410 --> 00:18:06,860
中文字幕
you might see some red unhappy faces or some yellow flat faces,

365
00:18:06,860 --> 00:18:09,950
中文字幕
which just means we couldn't even run the checks because something else is

366
00:18:09,950 --> 00:18:10,590
中文字幕
wrong.

367
00:18:10,590 --> 00:18:14,480
中文字幕
But over time, this will help you feel more comfortable and more confident

368
00:18:14,480 --> 00:18:18,500
中文字幕
that your code's correct before you actually use submit50 and submit.

369
00:18:18,500 --> 00:18:21,170
中文字幕
Going into it you'll feel a little better or a little frustrated

370
00:18:21,170 --> 00:18:24,470
中文字幕
to know in advance-- wait a minute, I'm about to submit this but nope,

371
00:18:24,470 --> 00:18:25,550
中文字幕
it's not yet correct.

372
00:18:25,550 --> 00:18:28,490
中文字幕
So realize it's a two-edged sword.

373
00:18:28,490 --> 00:18:34,470
中文字幕
Any questions about check50 or any of these commands thus far?

374
00:18:34,470 --> 00:18:36,970
中文字幕
Anything at all?

375
00:18:36,970 --> 00:18:37,740
中文字幕
No?

376
00:18:37,740 --> 00:18:38,240
中文字幕
All right.

377
00:18:38,240 --> 00:18:41,030
中文字幕
So let's take a look at the final and most powerful

378
00:18:41,030 --> 00:18:45,380
中文字幕
tool now available to you in the IDE environment.

379
00:18:45,380 --> 00:18:49,110
中文字幕
Built in to CS50 IDE, which stands for Integrated Development

380
00:18:49,110 --> 00:18:52,160
中文字幕
Environment, which isn't a CS50 thing-- this is a common term in industry

381
00:18:52,160 --> 00:18:54,780
中文字幕
for tools that make it easier to write code,

382
00:18:54,780 --> 00:18:58,470
中文字幕
it turns out that there's some other feature besides the cat over here.

383
00:18:58,470 --> 00:19:00,920
中文字幕
Namely, one, you can share your workspace

384
00:19:00,920 --> 00:19:03,090
中文字幕
with teaching fellows and course assistants

385
00:19:03,090 --> 00:19:06,230
中文字幕
so they can perhaps help you in real time a la Google Docs, even chatting

386
00:19:06,230 --> 00:19:07,370
中文字幕
with you in real time.

387
00:19:07,370 --> 00:19:09,910
中文字幕
But it also provides you with what's called a debugger.

388
00:19:09,910 --> 00:19:12,320
中文字幕
A debugger, as the name suggests, removes bugs--

389
00:19:12,320 --> 00:19:15,350
中文字幕
or rather, helps you remove bugs from your code

390
00:19:15,350 --> 00:19:17,630
中文字幕
by allowing you to not just resort to printf--

391
00:19:17,630 --> 00:19:19,700
中文字幕
printing out ints and strings and whatever

392
00:19:19,700 --> 00:19:22,580
中文字幕
is good that's going on your program, it kind of automates

393
00:19:22,580 --> 00:19:24,140
中文字幕
that very tedious process for you.

394
00:19:24,140 --> 00:19:26,330
中文字幕
And it lets you walk through your code one

395
00:19:26,330 --> 00:19:29,330
中文字幕
line at a time at your own comfortable pace

396
00:19:29,330 --> 00:19:33,980
中文字幕
and see along the way all of the values of your variables in that program.

397
00:19:33,980 --> 00:19:36,900
中文字幕
To activate this debugger, I'm going to go ahead and do the following.

398
00:19:36,900 --> 00:19:39,960
中文字幕
I'm going to compile my code as always with make hello.

399
00:19:39,960 --> 00:19:42,340
中文字幕
It has to compile, otherwise I might want

400
00:19:42,340 --> 00:19:44,510
中文字幕
to use help50 and figure out why it's not compiling,

401
00:19:44,510 --> 00:19:46,250
中文字幕
but it does seem to have compiled.

402
00:19:46,250 --> 00:19:50,210
中文字幕
And now I'm going to go ahead and run debug50, space, and then

403
00:19:50,210 --> 00:19:52,280
中文字幕
the name of the program I wanted to debug.

404
00:19:52,280 --> 00:19:54,730
中文字幕
And the name of the program I wanted to debug at the moment

405
00:19:54,730 --> 00:19:56,690
中文字幕
is the current directory's file called hello.

406
00:19:56,690 --> 00:19:59,100
中文字幕
Let's assume that there's perhaps something wrong with it.

407
00:19:59,100 --> 00:20:01,410
中文字幕
The first time I run this command, though, debug50

408
00:20:01,410 --> 00:20:03,870
中文字幕
is not going to be happy with me because it's going to say,

409
00:20:03,870 --> 00:20:06,270
中文字幕
it looks like you haven't set any breakpoints.

410
00:20:06,270 --> 00:20:09,380
中文字幕
Set at least one breakpoint by clicking to the left of a line number

411
00:20:09,380 --> 00:20:10,920
中文字幕
and then rerun debug50.

412
00:20:10,920 --> 00:20:12,170
中文字幕
Well what is a breakpoint?

413
00:20:12,170 --> 00:20:14,420
中文字幕
Well as the name kind of suggests, it allows

414
00:20:14,420 --> 00:20:19,130
中文字幕
you to break or pause the running of your code at any of your lines.

415
00:20:19,130 --> 00:20:21,620
中文字幕
And all this time for the past few weeks,

416
00:20:21,620 --> 00:20:23,480
中文字幕
your code been automatically line-numbered.

417
00:20:23,480 --> 00:20:27,110
中文字幕
And this is useful because the most interesting line in this program,

418
00:20:27,110 --> 00:20:29,880
中文字幕
once it really gets going, isn't this stuff at the top,

419
00:20:29,880 --> 00:20:31,130
中文字幕
it's not int main void, right?

420
00:20:31,130 --> 00:20:33,650
中文字幕
That's all copy-paste from past programs.

421
00:20:33,650 --> 00:20:37,910
中文字幕
It's really the sixth line here where I actually have some logic of my own.

422
00:20:37,910 --> 00:20:41,360
中文字幕
And so in CS50 IDE, what you can now do is

423
00:20:41,360 --> 00:20:43,340
中文字幕
click to the left of one of these line numbers,

424
00:20:43,340 --> 00:20:46,460
中文字幕
a little red light like a stop sign is going to appear saying,

425
00:20:46,460 --> 00:20:49,700
中文字幕
break or pause my program on this line so

426
00:20:49,700 --> 00:20:52,130
中文字幕
that I can poke around my actual code.

427
00:20:52,130 --> 00:20:54,180
中文字幕
Sandbox and Lab cannot do this.

428
00:20:54,180 --> 00:20:58,970
中文字幕
So now I'm going to go ahead and rerun debug50 in exactly the same way, hit

429
00:20:58,970 --> 00:21:01,400
中文字幕
Enter, but now I have one breakpoint.

430
00:21:01,400 --> 00:21:05,390
中文字幕
And you'll see on the right-hand side a fancier menu just popped up

431
00:21:05,390 --> 00:21:07,820
中文字幕
by the cat that provides me with a bunch of features.

432
00:21:07,820 --> 00:21:10,160
中文字幕
And at first glance, frankly, it's a little overwhelming

433
00:21:10,160 --> 00:21:13,940
中文字幕
because there's a lot going on here, but you'll notice first,

434
00:21:13,940 --> 00:21:17,540
中文字幕
and most importantly, there's some mention of my name variable.

435
00:21:17,540 --> 00:21:21,470
中文字幕
I don't quite understand 0x0 or whatnot, but I do understand string.

436
00:21:21,470 --> 00:21:26,240
中文字幕
And so what the debug50 program has realized is oh, on this line and below,

437
00:21:26,240 --> 00:21:28,160
中文字幕
you have a variable called name.

438
00:21:28,160 --> 00:21:29,950
中文字幕
It doesn't seem to have a value yet.

439
00:21:29,950 --> 00:21:33,890
中文字幕
0x0, it turns out, is just going to mean empty or null or 0.

440
00:21:33,890 --> 00:21:37,400
中文字幕
But that's good, because now, when I actually execute this line,

441
00:21:37,400 --> 00:21:41,000
中文字幕
hopefully it's going to take on the name David or Veronica or Brian.

442
00:21:41,000 --> 00:21:42,510
中文字幕
So let's see what happens.

443
00:21:42,510 --> 00:21:46,010
中文字幕
Notice that it's highlighted in yellow, line 6, which means it

444
00:21:46,010 --> 00:21:48,440
中文字幕
has not yet executed this line of code.

445
00:21:48,440 --> 00:21:52,670
中文字幕
My code has paused at this point because I set that breakpoint.

446
00:21:52,670 --> 00:21:57,260
中文字幕
And then notice kind of like a music player up here, there's a few icons.

447
00:21:57,260 --> 00:21:59,930
中文字幕
The Play button is just going to say, ah, play my program,

448
00:21:59,930 --> 00:22:03,200
中文字幕
run it all the way through the end, kind of like scratch with the green flag.

449
00:22:03,200 --> 00:22:04,970
中文字幕
But more powerful is this.

450
00:22:04,970 --> 00:22:09,110
中文字幕
You can step over this line, therefore executing it just once.

451
00:22:09,110 --> 00:22:12,020
中文字幕
If it's a function, you can step into this line

452
00:22:12,020 --> 00:22:15,710
中文字幕
and actually look inside of a function that you're using, like get_string,

453
00:22:15,710 --> 00:22:19,500
中文字幕
or you can step out of another function, but more on that another time.

454
00:22:19,500 --> 00:22:20,850
中文字幕
So what I'm going to do is this.

455
00:22:20,850 --> 00:22:23,900
中文字幕
And the button I'm going to click most commonly when trying to understand

456
00:22:23,900 --> 00:22:25,350
中文字幕
how my program is working is this--

457
00:22:25,350 --> 00:22:26,340
中文字幕
Step Over.

458
00:22:26,340 --> 00:22:31,670
中文字幕
So it's the second icon from the left, right next to the triangle.

459
00:22:31,670 --> 00:22:34,230
中文字幕
So once I click this, watch what's going to happen,

460
00:22:34,230 --> 00:22:38,630
中文字幕
even though it's a little small, on the right-hand side for my name variable.

461
00:22:38,630 --> 00:22:41,510
中文字幕
Notice that I'm being prompted to type in my name because the program

462
00:22:41,510 --> 00:22:44,630
中文字幕
is still running in my terminal window, but when I hit Enter now,

463
00:22:44,630 --> 00:22:49,310
中文字幕
providing my own name, automatically you see on the right-hand side

464
00:22:49,310 --> 00:22:53,270
中文字幕
that this name variable has a value now of, quote-unquote,

465
00:22:53,270 --> 00:22:55,020
中文字幕
"David" of type string.

466
00:22:55,020 --> 00:22:59,240
中文字幕
There's this 0x1083010-- more on that later, just a little cryptic,

467
00:22:59,240 --> 00:23:02,260
中文字幕
but I didn't have to use printf now, I can actually see what's going on.

468
00:23:02,260 --> 00:23:04,410
中文字幕
Now you can see that line 7 is highlighted,

469
00:23:04,410 --> 00:23:07,160
中文字幕
because I set a breakpoint above it, so now I'm on the second line

470
00:23:07,160 --> 00:23:08,540
中文字幕
because I just stepped into it.

471
00:23:08,540 --> 00:23:11,090
中文字幕
Let me go ahead and click Next again, and you'll

472
00:23:11,090 --> 00:23:14,300
中文字幕
see that in my terminal window, hello, David just got executed.

473
00:23:14,300 --> 00:23:17,330
中文字幕
And now if I just keep going, it's going to go ahead and run to the end

474
00:23:17,330 --> 00:23:18,810
中文字幕
and close the debugger.

475
00:23:18,810 --> 00:23:21,530
中文字幕
So not all that useful for this program because frankly, I'm

476
00:23:21,530 --> 00:23:25,550
中文字幕
pretty sure this is correct, but the power of debug50 and a debugger more

477
00:23:25,550 --> 00:23:28,700
中文字幕
generally is that it lets you, whether you're less comfy or more comfy,

478
00:23:28,700 --> 00:23:33,050
中文字幕
walk through your own code at your pace just like a TF or a CA might say, OK,

479
00:23:33,050 --> 00:23:34,050
中文字幕
what is this line doing?

480
00:23:34,050 --> 00:23:35,160
中文字幕
What is this line doing?

481
00:23:35,160 --> 00:23:38,440
中文字幕
You don't have to resort to printf, you can just very methodically

482
00:23:38,440 --> 00:23:41,410
中文字幕
walk through your code and find that damn bug that's been bothering you

483
00:23:41,410 --> 00:23:43,120
中文字幕
for minutes or even hours.

484
00:23:43,120 --> 00:23:47,530
中文字幕
So henceforth, any time you have a bug in your code that is compiling

485
00:23:47,530 --> 00:23:51,010
中文字幕
but it's just logically incorrect-- the pyramid in Mario isn't quite right,

486
00:23:51,010 --> 00:23:53,920
中文字幕
your encryption of Caesar isn't quite right, or something else,

487
00:23:53,920 --> 00:23:58,240
中文字幕
your first instinct now should be, let me compile it, run debug50 on it,

488
00:23:58,240 --> 00:24:01,910
中文字幕
and just step through the code, setting a breakpoint wherever I want,

489
00:24:01,910 --> 00:24:04,450
中文字幕
so you focus on just a few lines, not the whole thing--

490
00:24:04,450 --> 00:24:05,500
中文字幕
like I just did--

491
00:24:05,500 --> 00:24:08,840
中文字幕
and see if you can figure out logically when a value is not what you expected,

492
00:24:08,840 --> 00:24:09,490
中文字幕
then oh--

493
00:24:09,490 --> 00:24:13,000
中文字幕
go ahead and just click Resume, fix the bug, and retry.

494
00:24:13,000 --> 00:24:15,110
中文字幕
Such a powerful tool.

495
00:24:15,110 --> 00:24:17,000
中文字幕
Any questions?

496
00:24:17,000 --> 00:24:19,180
中文字幕
Yeah?

497
00:24:19,180 --> 00:24:19,710
中文字幕
What is it?

498
00:24:19,710 --> 00:24:21,780
中文字幕
AUDIENCE: What does it look like when there is a bug?

499
00:24:21,780 --> 00:24:24,110
中文字幕
What does it look like when there is a bug?

500
00:24:24,110 --> 00:24:28,170
中文字幕
So the debugger won't find your bugs and it won't show you your bugs, per se.

501
00:24:28,170 --> 00:24:31,130
中文字幕
It's going to let you see what line is executing,

502
00:24:31,130 --> 00:24:32,970
中文字幕
it's going to let you see what's outputting,

503
00:24:32,970 --> 00:24:34,950
中文字幕
it's going to let you take input, but all it's

504
00:24:34,950 --> 00:24:36,940
中文字幕
going to do on that right-hand side is just show

505
00:24:36,940 --> 00:24:38,910
中文字幕
you the values of things along the way.

506
00:24:38,910 --> 00:24:42,840
中文字幕
It's up to you to infer from that information what

507
00:24:42,840 --> 00:24:46,140
中文字幕
it is that's going wrong, just like if you're using printf in past weeks

508
00:24:46,140 --> 00:24:48,420
中文字幕
to see what's going on in your program.

509
00:24:48,420 --> 00:24:50,590
中文字幕
Other questions?

510
00:24:50,590 --> 00:24:52,360
中文字幕
And let me save this too.

511
00:24:52,360 --> 00:24:55,600
中文字幕
It is so easy to get into the habit, especially when so many things have

512
00:24:55,600 --> 00:24:57,940
中文字幕
been new over the past few weeks of just saying, ah,

513
00:24:57,940 --> 00:24:59,860
中文字幕
this is just yet another thing to learn.

514
00:24:59,860 --> 00:25:02,620
中文字幕
This is hands down the kind of tool that if you

515
00:25:02,620 --> 00:25:05,620
中文字幕
spend a few extra minutes this week and next week just using it,

516
00:25:05,620 --> 00:25:07,330
中文字幕
get a little more comfortable with it, it

517
00:25:07,330 --> 00:25:09,920
中文字幕
will save you potentially hours in the long run,

518
00:25:09,920 --> 00:25:12,010
中文字幕
because all the time you've been spending manually

519
00:25:12,010 --> 00:25:14,550
中文字幕
trying to fix your bugs or posting questions online

520
00:25:14,550 --> 00:25:16,420
中文字幕
trying to understand things, this is a tool

521
00:25:16,420 --> 00:25:18,640
中文字幕
that if you invest those minutes upfront will just

522
00:25:18,640 --> 00:25:21,340
中文字幕
help you understand everything going on inside of your program,

523
00:25:21,340 --> 00:25:27,190
中文字幕
and will absolutely over the next few weeks save you more and more time.

524
00:25:27,190 --> 00:25:30,660
中文字幕
All right, any questions? yeah?

525
00:25:30,660 --> 00:25:34,060
中文字幕
AUDIENCE: So you have a for loop that ran [INAUDIBLE] times,

526
00:25:34,060 --> 00:25:38,190
中文字幕
[INAUDIBLE] separate break statements so you don't have to [INAUDIBLE]..

527
00:25:38,190 --> 00:25:39,490
中文字幕
Ah, good question.

528
00:25:39,490 --> 00:25:42,150
中文字幕
If you have something like a for loop or a while loop, something

529
00:25:42,150 --> 00:25:45,630
中文字幕
that's happening a lot, can you set a breakpoint in such a way

530
00:25:45,630 --> 00:25:49,380
中文字幕
that it only breaks so that you don't have to walk through it 100 times

531
00:25:49,380 --> 00:25:50,340
中文字幕
just to see that value?

532
00:25:50,340 --> 00:25:51,480
中文字幕
Short answer, yes.

533
00:25:51,480 --> 00:25:54,720
中文字幕
And let me defer to section and online resources for just a few

534
00:25:54,720 --> 00:25:57,240
中文字幕
of these features, but one, you can actually watch values,

535
00:25:57,240 --> 00:25:59,320
中文字幕
and you can have what's called a watch expression.

536
00:25:59,320 --> 00:26:03,330
中文字幕
You can say show me this value if only when x is greater than 50

537
00:26:03,330 --> 00:26:04,470
中文字幕
or something like that.

538
00:26:04,470 --> 00:26:06,840
中文字幕
Or you yourself can just add some lines of code.

539
00:26:06,840 --> 00:26:11,430
中文字幕
You could add a, if x equals-equals 50, then print out something,

540
00:26:11,430 --> 00:26:14,080
中文字幕
and you can set a breakpoint on that new, if temporary line,

541
00:26:14,080 --> 00:26:15,720
中文字幕
so there's a couple of ways to do that.

542
00:26:15,720 --> 00:26:16,890
中文字幕
Good question to anticipate.

543
00:26:16,890 --> 00:26:17,390
中文字幕
Yeah?

544
00:26:17,390 --> 00:26:18,180
中文字幕
Behind.

545
00:26:18,180 --> 00:26:22,020
中文字幕
AUDIENCE: If you run debug50, aren't you adding

546
00:26:22,020 --> 00:26:26,990
中文字幕
another arugment with the [INAUDIBLE] in your main method at line 4?

547
00:26:26,990 --> 00:26:28,410
中文字幕
Really good question.

548
00:26:28,410 --> 00:26:30,450
中文字幕
If you're running debug50, aren't you adding

549
00:26:30,450 --> 00:26:33,540
中文字幕
another argument-- argv-- per our discussion last week of command line

550
00:26:33,540 --> 00:26:34,320
中文字幕
arguments?

551
00:26:34,320 --> 00:26:36,820
中文字幕
Short answer, no, because debug50 corrects for that,

552
00:26:36,820 --> 00:26:38,410
中文字幕
so you don't have to worry about that.

553
00:26:38,410 --> 00:26:40,530
中文字幕
It will not shift things over numerically.

554
00:26:40,530 --> 00:26:41,730
中文字幕
Really good thought.

555
00:26:41,730 --> 00:26:43,800
中文字幕
Other questions?

556
00:26:43,800 --> 00:26:50,040
中文字幕
All right, so with that said, let's now take some training wheels off.

557
00:26:50,040 --> 00:26:53,070
中文字幕
So the only reason I bought these training wheels years ago

558
00:26:53,070 --> 00:26:57,870
中文字幕
is to make this very dramatic point of now taking the training wheels off

559
00:26:57,870 --> 00:26:59,660
中文字幕
today.

560
00:26:59,660 --> 00:27:01,470
中文字幕
OK, so what does this mean?

561
00:27:01,470 --> 00:27:03,300
中文字幕
Well worth the trip to Target.

562
00:27:03,300 --> 00:27:04,350
中文字幕
So what does this mean?

563
00:27:04,350 --> 00:27:07,110
中文字幕
For the past few weeks, we have been using a whole bunch

564
00:27:07,110 --> 00:27:09,310
中文字幕
of functions from CS50's library.

565
00:27:09,310 --> 00:27:12,500
中文字幕
All of these were meant to just make it pretty easy, relatively speaking,

566
00:27:12,500 --> 00:27:14,710
中文字幕
in the first few weeks to get input from the user.

567
00:27:14,710 --> 00:27:16,420
中文字幕
Because it turns out, as we'll see today,

568
00:27:16,420 --> 00:27:20,910
中文字幕
it's actually a kind of a pain in the neck to get input from users in C,

569
00:27:20,910 --> 00:27:23,830
中文字幕
and frankly, even in other languages reliability.

570
00:27:23,830 --> 00:27:27,000
中文字幕
Because you'll recall that get_string and get_int and all of these functions

571
00:27:27,000 --> 00:27:30,180
中文字幕
take on the burden of like re-prompting the user if they don't actually

572
00:27:30,180 --> 00:27:32,130
中文字幕
give you an an int or don't give you a float

573
00:27:32,130 --> 00:27:34,880
中文字幕
or don't give you a char that you're expecting, they'll re-prompt,

574
00:27:34,880 --> 00:27:37,290
中文字幕
they're using a while loop or a do-while loop or the like,

575
00:27:37,290 --> 00:27:40,200
中文字幕
so there's just a lot of error detection built into these functions.

576
00:27:40,200 --> 00:27:44,370
中文字幕
But, most importantly-- and most misleadingly,

577
00:27:44,370 --> 00:27:46,470
中文字幕
has been the last one on this list.

578
00:27:46,470 --> 00:27:50,400
中文字幕
Recall that we introduced a couple weeks ago now the notion of a string.

579
00:27:50,400 --> 00:27:53,570
中文字幕
And a string is in English what?

580
00:27:53,570 --> 00:27:54,780
中文字幕
An array of characters, good.

581
00:27:54,780 --> 00:27:57,300
中文字幕
It's a sequence of characters, and we learned last week that a sequence can

582
00:27:57,300 --> 00:27:59,750
中文字幕
be implemented in an array, which is just a chunk of memory

583
00:27:59,750 --> 00:28:01,290
中文字幕
back-to-back-to-back-to-back.

584
00:28:01,290 --> 00:28:06,120
中文字幕
So string, though, is not quite like any of those other data types.

585
00:28:06,120 --> 00:28:10,800
中文字幕
It turns out that it's not quite like int or char or even bool or float,

586
00:28:10,800 --> 00:28:13,480
中文字幕
and we can start to see that now as follows.

587
00:28:13,480 --> 00:28:15,520
中文字幕
I'm going to go ahead and go into the IDE today--

588
00:28:15,520 --> 00:28:17,810
中文字幕
and henceforth we're going to just start using the IDE,

589
00:28:17,810 --> 00:28:20,940
中文字幕
but you're welcome to keep using the Sandbox for quick and dirty programs,

590
00:28:20,940 --> 00:28:22,650
中文字幕
but for anything you want to keep around,

591
00:28:22,650 --> 00:28:24,930
中文字幕
your instinct should now be to open your IDE.

592
00:28:24,930 --> 00:28:26,770
中文字幕
I'm going to go ahead and create a new file,

593
00:28:26,770 --> 00:28:31,710
中文字幕
and I'm going to call it compare0.c from my first example of comparing things.

594
00:28:31,710 --> 00:28:34,860
中文字幕
And I'm going to go ahead and whip up a relatively short program

595
00:28:34,860 --> 00:28:37,130
中文字幕
that you would hope would work right out of the box.

596
00:28:37,130 --> 00:28:40,230
中文字幕
So I'm going to go ahead and include the familiar cs50.h.

597
00:28:40,230 --> 00:28:42,540
中文字幕
I'm going to go include stdio.h.

598
00:28:42,540 --> 00:28:44,710
中文字幕
I'm going to go ahead and do int main void.

599
00:28:44,710 --> 00:28:46,390
中文字幕
I'm going to go ahead and in here--

600
00:28:46,390 --> 00:28:49,800
中文字幕
let me a variable called i using get_int from the user,

601
00:28:49,800 --> 00:28:51,750
中文字幕
and just prompt them for i.

602
00:28:51,750 --> 00:28:55,080
中文字幕
Let me go ahead then and prompt the user for another get_int.

603
00:28:55,080 --> 00:28:57,290
中文字幕
We'll call it j and get that from them.

604
00:28:57,290 --> 00:28:59,000
中文字幕
And then let's just compare these things.

605
00:28:59,000 --> 00:29:03,120
中文字幕
So if i equals-equals j, then go ahead and print out

606
00:29:03,120 --> 00:29:05,730
中文字幕
with printf same and a new line.

607
00:29:05,730 --> 00:29:10,870
中文字幕
Then go ahead and print out the opposite, which is different.

608
00:29:10,870 --> 00:29:13,920
中文字幕
So the only place I think I could have screwed up, perhaps,

609
00:29:13,920 --> 00:29:16,200
中文字幕
is if I did this, which is kind of reasonable if you

610
00:29:16,200 --> 00:29:17,780
中文字幕
come in knowing what an equal sign is.

611
00:29:17,780 --> 00:29:20,250
中文字幕
But again, in code, we typically need two equal signs

612
00:29:20,250 --> 00:29:21,710
中文字幕
because that compares two values.

613
00:29:21,710 --> 00:29:24,750
中文字幕
So I didn't make that mistake, I'm feeling pretty good about this.

614
00:29:24,750 --> 00:29:28,170
中文字幕
Let me save it with Command-S or Control-S or via File,

615
00:29:28,170 --> 00:29:31,840
中文字幕
Save; go to my prompt and run make compare0.

616
00:29:31,840 --> 00:29:33,450
中文字幕
Good, everything compiled.

617
00:29:33,450 --> 00:29:38,760
中文字幕
And let me go ahead and run compare0, Enter, and I'll type in 50,

618
00:29:38,760 --> 00:29:42,240
中文字幕
and I'll type in 50, and they do seem to be the same.

619
00:29:42,240 --> 00:29:46,530
中文字幕
Let me go ahead and do that again, let's type in 42 and 13,

620
00:29:46,530 --> 00:29:47,490
中文字幕
and they are different.

621
00:29:47,490 --> 00:29:50,690
中文字幕
And I should probably test a few more, maybe some negative values, maybe some

622
00:29:50,690 --> 00:29:52,600
中文字幕
0's, positive values and the like, but I'm

623
00:29:52,600 --> 00:29:54,900
中文字幕
feeling pretty good about the correctness of this code.

624
00:29:54,900 --> 00:29:55,500
中文字幕
All right.

625
00:29:55,500 --> 00:29:57,210
中文字幕
So let's change this program a bit.

626
00:29:57,210 --> 00:29:59,130
中文字幕
Let me go ahead and create another file, which

627
00:29:59,130 --> 00:30:02,470
中文字幕
I can do with the little green plus or via File, New File.

628
00:30:02,470 --> 00:30:04,670
中文字幕
I'm going to go ahead save this one as compare1.c.

629
00:30:04,670 --> 00:30:08,880
中文字幕
And for the moment I'm going to go ahead and just paste in that code

630
00:30:08,880 --> 00:30:11,340
中文字幕
from before, but I'm going to make some changes now.

631
00:30:11,340 --> 00:30:16,170
中文字幕
I'm going to go ahead and rename and retype my data types as strings.

632
00:30:16,170 --> 00:30:18,840
中文字幕
So give me a string called s, and will prompt the user

633
00:30:18,840 --> 00:30:21,000
中文字幕
for that using get_string, then I'm going

634
00:30:21,000 --> 00:30:23,880
中文字幕
to go ahead and change this 1 to string t,

635
00:30:23,880 --> 00:30:25,860
中文字幕
and I'm going to go ahead and get get_string.

636
00:30:25,860 --> 00:30:30,180
中文字幕
I, of course, need to now compare s and t, not i and j.

637
00:30:30,180 --> 00:30:33,510
中文字幕
And s is a common variable name for a string. t just comes after s,

638
00:30:33,510 --> 00:30:36,860
中文字幕
so that's pretty reasonable too, but I should of course update that as well.

639
00:30:36,860 --> 00:30:39,390
中文字幕
And so I think everything's now the same logically.

640
00:30:39,390 --> 00:30:41,940
中文字幕
I just changed my data types and my variable names.

641
00:30:41,940 --> 00:30:42,930
中文字幕
So I've saved this.

642
00:30:42,930 --> 00:30:45,380
中文字幕
Let me go ahead and run make compare1.

643
00:30:45,380 --> 00:30:47,110
中文字幕
Good, everything's correct.

644
00:30:47,110 --> 00:30:51,630
中文字幕
Let me go ahead and do ./compare1.

645
00:30:51,630 --> 00:30:56,280
中文字幕
Let me go ahead and type in Brian and Veronica.

646
00:30:56,280 --> 00:30:58,380
中文字幕
And of course, those are different.

647
00:30:58,380 --> 00:31:01,770
中文字幕
Now let me go ahead and type in David, let me type in David again,

648
00:31:01,770 --> 00:31:05,590
中文字幕
and those of course are different?

649
00:31:05,590 --> 00:31:06,090
中文字幕
Huh.

650
00:31:06,090 --> 00:31:08,470
中文字幕
Maybe it's because I just hit the Spacebar or something.

651
00:31:08,470 --> 00:31:11,550
中文字幕
So let's try Erin.

652
00:31:11,550 --> 00:31:12,720
中文字幕
Her name's a little shorter.

653
00:31:12,720 --> 00:31:13,800
中文字幕
Hmm.

654
00:31:13,800 --> 00:31:16,530
中文字幕
OK, let's try-- oh, what's her name?

655
00:31:16,530 --> 00:31:17,040
中文字幕
TJ.

656
00:31:17,040 --> 00:31:19,000
中文字幕
OK, even shorter, perfect.

657
00:31:19,000 --> 00:31:21,280
中文字幕
TJ, can't go wrong.

658
00:31:21,280 --> 00:31:21,780
中文字幕
Different.

659
00:31:21,780 --> 00:31:23,140
中文字幕
I mean, what is going on?

660
00:31:23,140 --> 00:31:25,590
中文字幕
Let's just say i, i.

661
00:31:25,590 --> 00:31:27,010
中文字幕
Different?

662
00:31:27,010 --> 00:31:29,650
中文字幕
So where's the logical bug in this program?

663
00:31:34,070 --> 00:31:36,460
中文字幕
What is it that's going on?

664
00:31:36,460 --> 00:31:37,480
中文字幕
Yeah, what do you think?

665
00:31:37,480 --> 00:31:39,190
中文字幕
AUDIENCE: Is it comparing integer values?

666
00:31:39,190 --> 00:31:40,570
中文字幕
Is it comparing integer values?

667
00:31:40,570 --> 00:31:41,140
中文字幕
Well maybe.

668
00:31:41,140 --> 00:31:43,150
中文字幕
I mean, thus far when we've used equal-equals

669
00:31:43,150 --> 00:31:45,520
中文字幕
we've probably used it mostly for comparing integers,

670
00:31:45,520 --> 00:31:47,560
中文字幕
so maybe I'm just misusing it, sure.

671
00:31:47,560 --> 00:31:48,860
中文字幕
Other thoughts?

672
00:31:51,680 --> 00:31:54,770
中文字幕
Oh, that's a big word that we'll get to in just a little bit.

673
00:31:54,770 --> 00:31:58,240
中文字幕
But correct, correct-- but for very similar reasons.

674
00:31:58,240 --> 00:32:02,650
中文字幕
So something's going on logically involving comparison,

675
00:32:02,650 --> 00:32:06,580
中文字幕
because I'm using equal-equal, but maybe I'm using it for the wrong data types?

676
00:32:06,580 --> 00:32:09,580
中文字幕
I mean, it's clearly broken for strings.

677
00:32:09,580 --> 00:32:11,890
中文字幕
So why might that actually be?

678
00:32:11,890 --> 00:32:16,450
中文字幕
Well it turns out that strings don't actually exist.

679
00:32:16,450 --> 00:32:19,150
中文字幕
So a string that we know is just a sequence of characters

680
00:32:19,150 --> 00:32:22,720
中文字幕
or an array of characters is not an actual data type.

681
00:32:22,720 --> 00:32:27,440
中文字幕
int is, float is, double is, long is, bool is, and even more

682
00:32:27,440 --> 00:32:28,870
中文字幕
are actual data types.

683
00:32:28,870 --> 00:32:30,970
中文字幕
String is kind of a little white lie we've

684
00:32:30,970 --> 00:32:35,170
中文字幕
been telling for a few weeks that's implemented only in the CS50 library.

685
00:32:35,170 --> 00:32:37,350
中文字幕
Now the word string is super common in programming.

686
00:32:37,350 --> 00:32:40,510
中文字幕
Like every programmer out there will know what you mean when you say string.

687
00:32:40,510 --> 00:32:44,740
中文字幕
That is not a CS50 word, but our use of it in C is CS50-specific.

688
00:32:44,740 --> 00:32:47,590
中文字幕
Because in that file called cs50.h, in addition

689
00:32:47,590 --> 00:32:50,290
中文字幕
to declaring functions like get_string and get_int and get_float

690
00:32:50,290 --> 00:32:53,860
中文字幕
and a bunch of other things, we also have a special line that says,

691
00:32:53,860 --> 00:32:57,760
中文字幕
create a data type called string.

692
00:32:57,760 --> 00:33:00,860
中文字幕
But what does it actually do or what does it actually mean?

693
00:33:00,860 --> 00:33:04,090
中文字幕
Well let's go ahead and consider what might be going on underneath the hood

694
00:33:04,090 --> 00:33:04,850
中文字幕
here.

695
00:33:04,850 --> 00:33:08,950
中文字幕
So if I go ahead and draw the program that we just

696
00:33:08,950 --> 00:33:12,490
中文字幕
ran, that program compare1 gets a string s from the user,

697
00:33:12,490 --> 00:33:15,730
中文字幕
then gets a string t from the user, and then compares them.

698
00:33:15,730 --> 00:33:18,500
中文字幕
So we know from last week what a string is, it's just an array.

699
00:33:18,500 --> 00:33:22,520
中文字幕
So when I run that first line of code and get a string from the user--

700
00:33:22,520 --> 00:33:28,270
中文字幕
for instance, Brian, I'm going to go ahead and see a B-R-I-A-N,

701
00:33:28,270 --> 00:33:33,410
中文字幕
which we know from last week to actually be an array of memory that might look

702
00:33:33,410 --> 00:33:36,040
中文字幕
pictorially like this-- and this, too, is a bit of a white lie,

703
00:33:36,040 --> 00:33:37,700
中文字幕
there's something else.

704
00:33:37,700 --> 00:33:38,560
中文字幕
AUDIENCE: The null.

705
00:33:38,560 --> 00:33:41,350
中文字幕
Yeah, the null character, so to speak, and ul,

706
00:33:41,350 --> 00:33:45,540
中文字幕
which we typically just write with a backslash 0, which is just all 0 bits.

707
00:33:45,540 --> 00:33:49,390
中文字幕
And it turns out, you might recall from the debugger earlier, you saw this--

708
00:33:49,390 --> 00:33:52,480
中文字幕
that's the even more cryptic way of expressing the null character,

709
00:33:52,480 --> 00:33:53,350
中文字幕
backslash 0.

710
00:33:53,350 --> 00:33:55,940
中文字幕
Just different programs display it in different ways.

711
00:33:55,940 --> 00:34:00,200
中文字幕
So when I get_string and type in Brian, this is what's allocated in memory.

712
00:34:00,200 --> 00:34:05,920
中文字幕
And when I type Veronica, I can see a V-E-R-O-N-I-C-A.

713
00:34:05,920 --> 00:34:07,630
中文字幕
I'm going to get that right preemptively.

714
00:34:07,630 --> 00:34:08,850
中文字幕
Backslash 0.

715
00:34:08,850 --> 00:34:12,190
中文字幕
That, too, is a chunk of memory, which I'll draw like this.

716
00:34:12,190 --> 00:34:16,980
中文字幕
1, 2, and split these up into interval characters or bytes.

717
00:34:16,980 --> 00:34:20,380
中文字幕
And recall from last time that these bytes just come from my memory,

718
00:34:20,380 --> 00:34:23,460
中文字幕
and that memory just has a bunch of bytes in it, maybe millions or even

719
00:34:23,460 --> 00:34:24,690
中文字幕
billions these days.

720
00:34:24,690 --> 00:34:26,830
中文字幕
And so honestly, if you just have that many things,

721
00:34:26,830 --> 00:34:29,290
中文字幕
any human or computer can certainly number them.

722
00:34:29,290 --> 00:34:31,600
中文字幕
Like this is byte 1, 2, 3, 4.

723
00:34:31,600 --> 00:34:34,030
中文字幕
So let's just assume for the sake of discussion

724
00:34:34,030 --> 00:34:36,610
中文字幕
that out of context of my computer's hardware,

725
00:34:36,610 --> 00:34:46,650
中文字幕
Brian just ended up at location 100, and location 101, and 102, 103, 104, 105.

726
00:34:46,650 --> 00:34:49,170
中文字幕
So this is the 100th byte in my computer,

727
00:34:49,170 --> 00:34:51,310
中文字幕
this is 105th byte in my computer, and Brian

728
00:34:51,310 --> 00:34:53,100
中文字幕
is using that many characters in total.

729
00:34:53,100 --> 00:34:55,030
中文字幕
Veronica, she ended up somewhere else.

730
00:34:55,030 --> 00:35:02,710
中文字幕
Maybe she ended up farther away just because at location 900, 901, 902, 903,

731
00:35:02,710 --> 00:35:09,910
中文字幕
904, 905, 906-- a lot more memory, 907, and 908--

732
00:35:09,910 --> 00:35:14,010
中文字幕
but you can see even more visually now that the length of Brian's name--

733
00:35:14,010 --> 00:35:18,390
中文字幕
strlen of Brian is what?

734
00:35:21,230 --> 00:35:22,950
中文字幕
I hear five and I hear six.

735
00:35:22,950 --> 00:35:24,330
中文字幕
The length of Brian's name--

736
00:35:24,330 --> 00:35:25,830
中文字幕
Brian, how long is your name?

737
00:35:25,830 --> 00:35:26,460
中文字幕
AUDIENCE: Five.

738
00:35:26,460 --> 00:35:28,830
中文字幕
OK, it is definitively five characters, that

739
00:35:28,830 --> 00:35:31,530
中文字幕
is the length of Brian's name, but you have

740
00:35:31,530 --> 00:35:35,370
中文字幕
to appreciate that in the computer, Brian's five-character name does indeed

741
00:35:35,370 --> 00:35:36,270
中文字幕
take up six bytes.

742
00:35:36,270 --> 00:35:39,750
中文字幕
So both answers are kind of correct, but the length of the string henceforth

743
00:35:39,750 --> 00:35:41,700
中文字幕
is always the number of actual characters.

744
00:35:41,700 --> 00:35:45,720
中文字幕
The amount of space it takes up is that plus 1 for the null character.

745
00:35:45,720 --> 00:35:49,710
中文字幕
So you can actually see why Brian's name takes up six bytes in this picture

746
00:35:49,710 --> 00:35:52,380
中文字幕
rather than just the actual length, which is five.

747
00:35:52,380 --> 00:35:55,620
中文字幕
So when you call get_string now, and when you call

748
00:35:55,620 --> 00:35:57,480
中文字幕
get_string and get another string--

749
00:35:57,480 --> 00:36:01,740
中文字幕
Brian and Veronica respectively, what is actually being handed back?

750
00:36:01,740 --> 00:36:04,350
中文字幕
A couple weeks ago, Erin came up and she kind of like

751
00:36:04,350 --> 00:36:07,200
中文字幕
handed me back a string, a student's name from the audience.

752
00:36:07,200 --> 00:36:11,970
中文字幕
On that piece of paper we thought was the student's name.

753
00:36:11,970 --> 00:36:13,030
中文字幕
But it's not.

754
00:36:13,030 --> 00:36:15,750
中文字幕
It turns out that when a function returns a value,

755
00:36:15,750 --> 00:36:20,310
中文字幕
it can pretty much only return a 1 byte or maybe 2 or 4 bytes.

756
00:36:20,310 --> 00:36:25,450
中文字幕
It can't return an arbitrary number of bytes, like six for Brian or 1, 2, 3,

757
00:36:25,450 --> 00:36:29,460
中文字幕
4, 5, 6, 7, 8, 9-- it cannot return 9 bytes for Veronica.

758
00:36:29,460 --> 00:36:32,850
中文字幕
And if you even type a whole paragraph or page of text,

759
00:36:32,850 --> 00:36:37,600
中文字幕
it can't return all of that text, it can only return a single value.

760
00:36:37,600 --> 00:36:40,440
中文字幕
So to your instinct earlier, what might actually

761
00:36:40,440 --> 00:36:44,730
中文字幕
be getting returned by get_string when the human has

762
00:36:44,730 --> 00:36:47,720
中文字幕
typed in a name like Brian or Veronica?

763
00:36:49,490 --> 00:36:50,870
中文字幕
The memory location.

764
00:36:50,870 --> 00:36:53,510
中文字幕
Indeed, an integer, or as you called it, a pointer,

765
00:36:53,510 --> 00:36:55,770
中文字幕
which we'll introduce more formally in just a moment.

766
00:36:55,770 --> 00:36:58,820
中文字幕
So when get_string string returns "Brian," quote-unquote,

767
00:36:58,820 --> 00:37:05,570
中文字幕
it's actually not returning B-R-I-A-N backslash 0, it is just returning 100.

768
00:37:05,570 --> 00:37:08,360
中文字幕
And when get_string returns Veronica, it's not returning her name,

769
00:37:08,360 --> 00:37:10,580
中文字幕
it's returning 900.

770
00:37:10,580 --> 00:37:13,780
中文字幕
And so if you realize that now, when you do does

771
00:37:13,780 --> 00:37:19,820
中文字幕
s equal-equal t, what question more mundanely are you actually asking?

772
00:37:19,820 --> 00:37:20,960
中文字幕
Yeah.

773
00:37:20,960 --> 00:37:24,200
中文字幕
Memory location and memory location-- does 100 equal 900?

774
00:37:24,200 --> 00:37:25,670
中文字幕
And obviously not.

775
00:37:25,670 --> 00:37:28,680
中文字幕
And so that is why Brian's name, Veronica's name,

776
00:37:28,680 --> 00:37:32,870
中文字幕
my name, TJ's name-- every word I typed in was of course different,

777
00:37:32,870 --> 00:37:36,560
中文字幕
because each input was ending up at a different location in memory.

778
00:37:36,560 --> 00:37:40,500
中文字幕
And even if I typed the same word like David twice, one David was going here,

779
00:37:40,500 --> 00:37:42,800
中文字幕
one David was going somewhere else, they were ending up

780
00:37:42,800 --> 00:37:44,050
中文字幕
at different memory locations.

781
00:37:44,050 --> 00:37:46,460
中文字幕
Maybe 100, maybe 900, maybe something else,

782
00:37:46,460 --> 00:37:48,920
中文字幕
but they were ending up in different locations in memory.

783
00:37:48,920 --> 00:37:51,890
中文字幕
So equal-equals does compare values, but dammit

784
00:37:51,890 --> 00:37:54,280
中文字幕
if it isn't comparing the wrong values.

785
00:37:54,280 --> 00:37:54,780
中文字幕
Yeah?

786
00:37:54,780 --> 00:37:56,900
中文字幕
AUDIENCE: Well what if you use some char*s?

787
00:37:56,900 --> 00:37:58,740
中文字幕
Ah, so we'll come back to that.

788
00:37:58,740 --> 00:38:00,490
中文字幕
Let me come back to that in just a moment.

789
00:38:00,490 --> 00:38:02,680
中文字幕
char* is actually intricately related.

790
00:38:02,680 --> 00:38:03,730
中文字幕
More on that in a moment.

791
00:38:03,730 --> 00:38:04,230
中文字幕
Yeah?

792
00:38:04,230 --> 00:38:06,170
中文字幕
AUDIENCE: If you add two integers in memory--

793
00:38:06,170 --> 00:38:06,650
中文字幕
Uh huh?

794
00:38:06,650 --> 00:38:09,090
中文字幕
AUDIENCE: Wouldn't they be in different places in memory?

795
00:38:09,090 --> 00:38:11,050
中文字幕
So you would return--

796
00:38:11,050 --> 00:38:12,720
中文字幕
so you need a different value.

797
00:38:12,720 --> 00:38:14,310
中文字幕
OK, really good question.

798
00:38:14,310 --> 00:38:19,700
中文字幕
So wait a minute, this same logic that I'm returning the address of something

799
00:38:19,700 --> 00:38:23,750
中文字幕
surely applies to integers as well or floating point values as well?

800
00:38:23,750 --> 00:38:25,910
中文字幕
Because if I type in the number 50 like I

801
00:38:25,910 --> 00:38:29,960
中文字幕
did earlier, that, too, is somewhere in memory-- like a box in memory,

802
00:38:29,960 --> 00:38:32,780
中文字幕
and that, too, has an address somewhere in memory,

803
00:38:32,780 --> 00:38:36,130
中文字幕
but it turns out, for reasons that you just alluded to, actually,

804
00:38:36,130 --> 00:38:38,540
中文字幕
ints are returned as their values.

805
00:38:38,540 --> 00:38:40,740
中文字幕
Chars are returned as their values.

806
00:38:40,740 --> 00:38:42,200
中文字幕
Bools are returned as their values.

807
00:38:42,200 --> 00:38:43,700
中文字幕
Floats are returned as their values.

808
00:38:43,700 --> 00:38:45,260
中文字幕
Strings are different.

809
00:38:45,260 --> 00:38:48,920
中文字幕
Strings are returned by their address.

810
00:38:48,920 --> 00:38:54,080
中文字幕
And those addresses, it turns out, are ultimately going to be called

811
00:38:54,080 --> 00:38:56,700
中文字幕
char*'s, which we'll see in just a moment.

812
00:38:56,700 --> 00:38:59,780
中文字幕
So how do we go about then fixing this fundamentally?

813
00:38:59,780 --> 00:39:03,170
中文字幕
Like even if you have no idea how to code this yet, just intuitively,

814
00:39:03,170 --> 00:39:06,030
中文字幕
if I do actually want to delete--

815
00:39:06,030 --> 00:39:09,670
中文字幕
if I do actually want to compare--

816
00:39:09,670 --> 00:39:10,170
中文字幕
sorry.

817
00:39:13,530 --> 00:39:14,050
中文字幕
OK.

818
00:39:14,050 --> 00:39:19,180
中文字幕
If I do want to go ahead and compare Brian and Veronica for equality,

819
00:39:19,180 --> 00:39:21,370
中文字幕
what do I want to do intuitively?

820
00:39:21,370 --> 00:39:23,050
中文字幕
I can't just compare their addresses.

821
00:39:23,050 --> 00:39:25,870
中文字幕
What do I need to do?

822
00:39:25,870 --> 00:39:27,950
中文字幕
Isolate the characters and then do what with them?

823
00:39:30,820 --> 00:39:31,570
中文字幕
Good.

824
00:39:31,570 --> 00:39:32,440
中文字幕
Yeah, good instincts.

825
00:39:32,440 --> 00:39:35,260
中文字幕
Use a for loop, use a while loop-- any kind of looping structure.

826
00:39:35,260 --> 00:39:37,180
中文字幕
And intuitively, compare the first characters,

827
00:39:37,180 --> 00:39:40,350
中文字幕
and if they're different, well then we know we don't have to go any further.

828
00:39:40,350 --> 00:39:43,140
中文字幕
B is not a V, so surely these names are different.

829
00:39:43,140 --> 00:39:44,230
中文字幕
But what about in my case?

830
00:39:44,230 --> 00:39:46,870
中文字幕
If it was David and David, you would compare the first two.

831
00:39:46,870 --> 00:39:48,460
中文字幕
D and D are the same.

832
00:39:48,460 --> 00:39:50,710
中文字幕
Compare the second two, A and A are the same.

833
00:39:50,710 --> 00:39:55,570
中文字幕
V and V, I and I, D and D, and then what am I going to hit last?

834
00:39:55,570 --> 00:39:56,500
中文字幕
Null character.

835
00:39:56,500 --> 00:39:58,660
中文字幕
And should I keep going beyond the null character?

836
00:39:58,660 --> 00:39:59,160
中文字幕
No.

837
00:39:59,160 --> 00:40:02,250
中文字幕
So this is the beauty of that super simple design for a string.

838
00:40:02,250 --> 00:40:07,750
中文字幕
Insofar as strings are identified by their starting address, just the byte

839
00:40:07,750 --> 00:40:10,390
中文字幕
at which they start, you still need to know

840
00:40:10,390 --> 00:40:14,650
中文字幕
how long they are, because otherwise how do where one word begins and ends

841
00:40:14,650 --> 00:40:16,330
中文字幕
and another word begins?

842
00:40:16,330 --> 00:40:20,320
中文字幕
And so the simple decision we made last week-- as did humans decades ago--

843
00:40:20,320 --> 00:40:25,600
中文字幕
to terminate all strings with backslash 0 or all 0's is a super handy trick,

844
00:40:25,600 --> 00:40:28,630
中文字幕
so that if I tell you that Brian starts at 100,

845
00:40:28,630 --> 00:40:31,120
中文字幕
you can infer that he ends where?

846
00:40:33,800 --> 00:40:37,400
中文字幕
At byte number 105 or 104, if you will, however you want to think about it,

847
00:40:37,400 --> 00:40:40,610
中文字幕
because all you need to do in linear time,

848
00:40:40,610 --> 00:40:43,640
中文字幕
if you will, left or right, is check-- backslash 0, backslash 0-- ah!

849
00:40:43,640 --> 00:40:46,790
中文字幕
Backslash 0, now I know how long Brian's name is.

850
00:40:46,790 --> 00:40:49,880
中文字幕
So let's consider for a moment this program called string length.

851
00:40:49,880 --> 00:40:52,460
中文字幕
How does strlen actually work?

852
00:40:52,460 --> 00:40:57,140
中文字幕
When you pass to strlen, a variable containing a string, like Brian,

853
00:40:57,140 --> 00:41:00,290
中文字幕
what is sterling probably doing?

854
00:41:02,340 --> 00:41:03,220
中文字幕
Exactly.

855
00:41:03,220 --> 00:41:05,740
中文字幕
It's looking at that null character's address

856
00:41:05,740 --> 00:41:09,340
中文字幕
and subtracting the start address and the end address,

857
00:41:09,340 --> 00:41:12,160
中文字幕
figuring out what the difference is, and actually returning

858
00:41:12,160 --> 00:41:14,890
中文字幕
that minus 1 the total count.

859
00:41:14,890 --> 00:41:16,940
中文字幕
And more mechanically, we'll see in a moment,

860
00:41:16,940 --> 00:41:19,090
中文字幕
it's probably doing exactly the same thing I did,

861
00:41:19,090 --> 00:41:20,350
中文字幕
which is, is this backslash 0?

862
00:41:20,350 --> 00:41:21,190
中文字幕
Is this backslash 0?

863
00:41:21,190 --> 00:41:22,780
中文字幕
Is this, is this, is this?

864
00:41:22,780 --> 00:41:25,840
中文字幕
I asked that question five times before I saw backslash 0.

865
00:41:25,840 --> 00:41:29,320
中文字幕
strlen is just a function some human wrote years ago

866
00:41:29,320 --> 00:41:31,930
中文字幕
that probably just has a simple for loop and an if condition,

867
00:41:31,930 --> 00:41:33,220
中文字幕
and then that's it.

868
00:41:33,220 --> 00:41:35,320
中文字幕
Because that person understood before we even

869
00:41:35,320 --> 00:41:39,050
中文字幕
did how strings are actually implemented.

870
00:41:39,050 --> 00:41:41,040
中文字幕
Any questions then?

871
00:41:41,040 --> 00:41:42,880
中文字幕
All right, so let's actually implement this.

872
00:41:42,880 --> 00:41:46,930
中文字幕
Let me go ahead and into my editor here, and make one other example here

873
00:41:46,930 --> 00:41:48,730
中文字幕
that I'm going to call compare2.

874
00:41:48,730 --> 00:41:55,150
中文字幕
I'm going to go ahead and do include cs50.h and include stdio.h,

875
00:41:55,150 --> 00:41:57,940
中文字幕
and then I'm going to do int main void, and I'm

876
00:41:57,940 --> 00:42:03,040
中文字幕
going to quickly now grab my code from before where I got strings

877
00:42:03,040 --> 00:42:06,380
中文字幕
and I compared them, but I have to obviously fix that comparison.

878
00:42:06,380 --> 00:42:08,290
中文字幕
So here's my code from before.

879
00:42:08,290 --> 00:42:10,130
中文字幕
I'm going to do this the right way.

880
00:42:10,130 --> 00:42:14,630
中文字幕
I'm going to call a function called compare_strings passing in s and t.

881
00:42:14,630 --> 00:42:16,870
中文字幕
Because as you proposed, we need to do some logic.

882
00:42:16,870 --> 00:42:18,910
中文字幕
We don't have to pass it to a function, but we could.

883
00:42:18,910 --> 00:42:20,610
中文字幕
We could just do a for loop here, but I'm

884
00:42:20,610 --> 00:42:23,600
中文字幕
going to go ahead and implement compare_strings as follows.

885
00:42:23,600 --> 00:42:28,150
中文字幕
If I want to write a function that returns a yes/no answer, what data type

886
00:42:28,150 --> 00:42:29,890
中文字幕
should it return?

887
00:42:29,890 --> 00:42:30,490
中文字幕
A bool.

888
00:42:30,490 --> 00:42:32,800
中文字幕
So we've not necessarily done this yet, but you

889
00:42:32,800 --> 00:42:36,280
中文字幕
can return a bool just like you can int or a char or something else.

890
00:42:36,280 --> 00:42:38,500
中文字幕
I'm going to call this function compare_strings.

891
00:42:38,500 --> 00:42:42,570
中文字幕
It's going to take in one string called a and another string called b,

892
00:42:42,570 --> 00:42:44,600
中文字幕
but I could call those anything I want.

893
00:42:44,600 --> 00:42:47,740
中文字幕
And now what's the easiest thing to check?

894
00:42:47,740 --> 00:42:50,810
中文字幕
If I pass two strings, a and b, or Brian and Veronica,

895
00:42:50,810 --> 00:42:53,770
中文字幕
what's the easiest question you can ask and just immediately say, nope,

896
00:42:53,770 --> 00:42:55,230
中文字幕
these are different?

897
00:42:55,230 --> 00:42:56,110
中文字幕
String length, right?

898
00:42:56,110 --> 00:43:00,190
中文字幕
Like if the B-R-I-A-N is not of the same length as Veronica's name,

899
00:43:00,190 --> 00:43:02,830
中文字幕
we don't need to do any logic whatsoever beyond that,

900
00:43:02,830 --> 00:43:04,540
中文字幕
we can just quit and say false.

901
00:43:04,540 --> 00:43:05,500
中文字幕
So let me just do that.

902
00:43:05,500 --> 00:43:10,430
中文字幕
If the strlen of a does not equal the strlen of b, you know what?

903
00:43:10,430 --> 00:43:13,300
中文字幕
Let's just go ahead and return false and get out of here.

904
00:43:13,300 --> 00:43:17,200
中文字幕
OK, but now, if we get past that gateway, so to speak,

905
00:43:17,200 --> 00:43:19,780
中文字幕
that check, that question, that Boolean expression,

906
00:43:19,780 --> 00:43:23,180
中文字幕
now I have to compare things character by character by character.

907
00:43:23,180 --> 00:43:26,390
中文字幕
So I can do this in a bunch of ways, but I like the suggestion of a for loop.

908
00:43:26,390 --> 00:43:30,610
中文字幕
So for int i at 0, n for efficiency-- actually,

909
00:43:30,610 --> 00:43:33,720
中文字幕
let's do i is less than the string length--

910
00:43:33,720 --> 00:43:36,820
中文字幕
should I do the string length of a or b?

911
00:43:36,820 --> 00:43:38,380
中文字幕
And it doesn't matter, right?

912
00:43:38,380 --> 00:43:39,430
中文字幕
So let's go with a.

913
00:43:39,430 --> 00:43:41,560
中文字幕
And frankly, had I been smart early on, I

914
00:43:41,560 --> 00:43:44,110
中文字幕
could have stored the value in a variable and then reused it,

915
00:43:44,110 --> 00:43:45,820
中文字幕
but we'll just keep going ahead for now.

916
00:43:45,820 --> 00:43:48,590
中文字幕
Then i plus-plus, but I remember from last time-- this is correct,

917
00:43:48,590 --> 00:43:49,710
中文字幕
but this is not good design.

918
00:43:49,710 --> 00:43:50,200
中文字幕
Why?

919
00:43:52,770 --> 00:43:55,980
中文字幕
Yeah, I keep calling strlen again and again, because remember, in a for loop,

920
00:43:55,980 --> 00:43:58,110
中文字幕
this condition is checked again and again

921
00:43:58,110 --> 00:44:00,160
中文字幕
and again-- you're just wasting your own time.

922
00:44:00,160 --> 00:44:02,970
中文字幕
So let me go ahead and actually do this.

923
00:44:02,970 --> 00:44:09,270
中文字幕
n or any variable equals the strlen of a, then just compare i against n,

924
00:44:09,270 --> 00:44:12,960
中文字幕
because now i is getting incremented, but n is never changing.

925
00:44:12,960 --> 00:44:15,250
中文字幕
So now let me go ahead and implement this for loop.

926
00:44:15,250 --> 00:44:21,510
中文字幕
So if-- how about the i-th character of a does not equal the i-th character

927
00:44:21,510 --> 00:44:24,780
中文字幕
of b, I can immediately conclude--

928
00:44:24,780 --> 00:44:28,410
中文字幕
nope, these strings can't be the same, because some letter, like a B,

929
00:44:28,410 --> 00:44:31,440
中文字幕
is not the same as another, like a V, or whatever letter we're actually

930
00:44:31,440 --> 00:44:32,580
中文字幕
comparing.

931
00:44:32,580 --> 00:44:34,380
中文字幕
And then I think that's it.

932
00:44:34,380 --> 00:44:37,590
中文字幕
If I get through these gauntlets of questions--

933
00:44:37,590 --> 00:44:38,850
中文字幕
are yours lengths different?

934
00:44:38,850 --> 00:44:40,100
中文字幕
Are your characters different?

935
00:44:40,100 --> 00:44:45,370
中文字幕
And I still haven't said false, what should I return by default?

936
00:44:45,370 --> 00:44:45,870
中文字幕
Yeah.

937
00:44:45,870 --> 00:44:49,060
中文字幕
Like if you make it through all of those questions and all is well,

938
00:44:49,060 --> 00:44:54,040
中文字幕
then D-A-V-I-D must indeed equal D-A-V-I-D or whatever the user actually

939
00:44:54,040 --> 00:44:54,920
中文字幕
typed in.

940
00:44:54,920 --> 00:44:56,140
中文字幕
Now I'm not quite done yet.

941
00:44:56,140 --> 00:44:58,780
中文字幕
When I've implemented a function or a helper function

942
00:44:58,780 --> 00:45:01,030
中文字幕
like this, because it's helping me do my work,

943
00:45:01,030 --> 00:45:02,680
中文字幕
what else do I have to add to the file?

944
00:45:02,680 --> 00:45:03,070
中文字幕
Oh?

945
00:45:03,070 --> 00:45:04,270
中文字幕
AUDIENCE: I've got a logical question.

946
00:45:04,270 --> 00:45:05,020
中文字幕
Sure.

947
00:45:05,020 --> 00:45:08,640
中文字幕
AUDIENCE: In a computer, couldn't you just type in David with a capital D

948
00:45:08,640 --> 00:45:11,540
中文字幕
and then david with a lowercase d, you're going to run [INAUDIBLE],,

949
00:45:11,540 --> 00:45:12,910
中文字幕
they're not going to sync because your first character's not

950
00:45:12,910 --> 00:45:13,780
中文字幕
the same character.

951
00:45:13,780 --> 00:45:14,660
中文字幕
Correct.

952
00:45:14,660 --> 00:45:17,240
中文字幕
So this is a feature, not a bug at the moment.

953
00:45:17,240 --> 00:45:20,040
中文字幕
My program at the moment is case-sensitive.

954
00:45:20,040 --> 00:45:22,790
中文字幕
If I type in DAVID and all caps, that is a different string

955
00:45:22,790 --> 00:45:25,460
中文字幕
I claim for now than david in all lowercase.

956
00:45:25,460 --> 00:45:27,590
中文字幕
If you want to tolerate uppercase and lowercase,

957
00:45:27,590 --> 00:45:29,090
中文字幕
you're going have to add more logic.

958
00:45:29,090 --> 00:45:32,460
中文字幕
But for now that's a design decision that I intend.

959
00:45:32,460 --> 00:45:32,960
中文字幕
All right.

960
00:45:32,960 --> 00:45:36,540
中文字幕
What else do I need to add to the program?

961
00:45:36,540 --> 00:45:38,050
中文字幕
Yeah, the prototype at top.

962
00:45:38,050 --> 00:45:41,140
中文字幕
You can literally copy and paste-- this is the only time copy and paste is

963
00:45:41,140 --> 00:45:43,210
中文字幕
probably a legitimate thing to do--

964
00:45:43,210 --> 00:45:45,880
中文字幕
at the top, and then semi-colon-- don't re-implement it.

965
00:45:45,880 --> 00:45:48,550
中文字幕
But I do need one other header file.

966
00:45:48,550 --> 00:45:54,740
中文字幕
I'm using a function that's not in cs50.h or in stdio.h.

967
00:45:54,740 --> 00:45:56,900
中文字幕
String length?

968
00:45:56,900 --> 00:45:58,630
中文字幕
Where was string length?

969
00:45:58,630 --> 00:45:59,840
中文字幕
Yeah, string.h.

970
00:45:59,840 --> 00:46:03,460
中文字幕
So I just need this, include string.h, save.

971
00:46:03,460 --> 00:46:05,510
中文字幕
Now this I think is correct.

972
00:46:05,510 --> 00:46:08,190
中文字幕
We'll see if I eat the word in a moment.

973
00:46:08,190 --> 00:46:10,700
中文字幕
But realize that if you're writing this code yourself,

974
00:46:10,700 --> 00:46:13,940
中文字幕
like this is not a natural thing to be writing a program in office hours

975
00:46:13,940 --> 00:46:16,640
中文字幕
or at home in your dorm and just getting it right the first time.

976
00:46:16,640 --> 00:46:19,970
中文字幕
This is after like 20 years of doing this, so realize we happen to be--

977
00:46:19,970 --> 00:46:21,720
中文字幕
and I also have a cheat sheet right here--

978
00:46:21,720 --> 00:46:23,750
中文字幕
we happen to be doing this correctly often,

979
00:46:23,750 --> 00:46:26,010
中文字幕
but realize that's not going to be the common case.

980
00:46:26,010 --> 00:46:28,490
中文字幕
So with that reassurance in mind, let's see

981
00:46:28,490 --> 00:46:33,140
中文字幕
if I have to now take all that back. make compare2.

982
00:46:33,140 --> 00:46:33,860
中文字幕
OK-- phew.

983
00:46:33,860 --> 00:46:34,700
中文字幕
20 years worked out.

984
00:46:34,700 --> 00:46:37,940
中文字幕
So now I'm going to go ahead and ./compare2.

985
00:46:37,940 --> 00:46:40,850
中文字幕
Let's type in Brian, let's type in Veronica.

986
00:46:40,850 --> 00:46:42,800
中文字幕
Those are indeed still different hopefully.

987
00:46:42,800 --> 00:46:45,680
中文字幕
Now let's try myself, David and David.

988
00:46:45,680 --> 00:46:46,530
中文字幕
Phew!

989
00:46:46,530 --> 00:46:47,330
中文字幕
Those are the same.

990
00:46:47,330 --> 00:46:52,550
中文字幕
And to your point, David in capitalized and David in all lowercase,

991
00:46:52,550 --> 00:46:56,780
中文字幕
different, but that's what I expect now.

992
00:46:56,780 --> 00:46:58,070
中文字幕
Any questions on compare2?

993
00:46:58,070 --> 00:46:58,570
中文字幕
Yeah?

994
00:47:01,830 --> 00:47:02,490
中文字幕
OK.

995
00:47:02,490 --> 00:47:06,740
中文字幕
string in the program and in general.

996
00:47:06,740 --> 00:47:07,400
中文字幕
OK.

997
00:47:07,400 --> 00:47:10,200
中文字幕
AUDIENCE: Would that still work [INAUDIBLE]

998
00:47:10,200 --> 00:47:12,290
中文字幕
If you were to hard code the strings?

999
00:47:12,290 --> 00:47:14,000
中文字幕
Short answer, yes, that would still work.

1000
00:47:14,000 --> 00:47:19,160
中文字幕
If you for whatever reason did not do this and using get_string,

1001
00:47:19,160 --> 00:47:25,100
中文字幕
but you did David, and here, for instance, David, that would work too.

1002
00:47:25,100 --> 00:47:28,080
中文字幕
And whatever your error is, if you can recreate it, just let us know.

1003
00:47:28,080 --> 00:47:31,570
中文字幕
AUDIENCE: It seems to be like a string that would be increased

1004
00:47:31,570 --> 00:47:33,560
中文字幕
for a set that was [INAUDIBLE] only?

1005
00:47:33,560 --> 00:47:36,550
中文字幕
And it was having issues in the little [INAUDIBLE]..

1006
00:47:36,550 --> 00:47:39,390
中文字幕
I'd have to see it to be sure, but happy to chat after.

1007
00:47:39,390 --> 00:47:42,090
中文字幕
All right, so let's see if we can't now clean this

1008
00:47:42,090 --> 00:47:45,790
中文字幕
up just a little bit as follows.

1009
00:47:45,790 --> 00:47:51,160
中文字幕
Let me go ahead here and reveal what it is that's actually going on.

1010
00:47:51,160 --> 00:47:53,990
中文字幕
So indeed, there is no such thing as a string.

1011
00:47:53,990 --> 00:47:55,830
中文字幕
And indeed, as you pointed out a moment ago,

1012
00:47:55,830 --> 00:47:57,370
中文字幕
it actually goes by a different name.

1013
00:47:57,370 --> 00:48:01,150
中文字幕
String is just a synonym for what's called a char*.

1014
00:48:01,150 --> 00:48:02,440
中文字幕
Now what does that even mean?

1015
00:48:02,440 --> 00:48:04,100
中文字幕
So char is the same as it's always been.

1016
00:48:04,100 --> 00:48:05,160
中文字幕
It's a single character.

1017
00:48:05,160 --> 00:48:09,820
中文字幕
Star in a program written in C could of course mean multiplication,

1018
00:48:09,820 --> 00:48:10,650
中文字幕
we have seen that.

1019
00:48:10,650 --> 00:48:12,270
中文字幕
This is another use of the star.

1020
00:48:12,270 --> 00:48:15,480
中文字幕
Whenever you see it after a data type like char,

1021
00:48:15,480 --> 00:48:19,500
中文字幕
this means that the data type in question is not just a char,

1022
00:48:19,500 --> 00:48:21,750
中文字幕
it's the address of a char.

1023
00:48:21,750 --> 00:48:25,330
中文字幕
So the star just means the address of whatever the data type is to the left,

1024
00:48:25,330 --> 00:48:27,330
中文字幕
and this is, as you pointed out earlier, what

1025
00:48:27,330 --> 00:48:29,170
中文字幕
we're going to start calling a pointer.

1026
00:48:29,170 --> 00:48:32,320
中文字幕
A pointer is, for all intents and purposes, an address.

1027
00:48:32,320 --> 00:48:34,650
中文字幕
It's just a buzzword to describe an address.

1028
00:48:34,650 --> 00:48:40,380
中文字幕
This data type here, char*, means I want a variable that doesn't store a char,

1029
00:48:40,380 --> 00:48:42,690
中文字幕
it stores the address of a char.

1030
00:48:42,690 --> 00:48:45,360
中文字幕
The number 100, the number 900.

1031
00:48:45,360 --> 00:48:48,330
中文字幕
But that address is just going to be called a pointer.

1032
00:48:48,330 --> 00:48:52,440
中文字幕
A pointer variable is a variable that stores the address of something.

1033
00:48:52,440 --> 00:48:54,850
中文字幕
A char or even other data types as well.

1034
00:48:54,850 --> 00:49:00,720
中文字幕
So with that in mind, let me actually quickly create compare3.c, paste this

1035
00:49:00,720 --> 00:49:05,670
中文字幕
in, and save it as compare3.c, and let me take off, if you will,

1036
00:49:05,670 --> 00:49:06,750
中文字幕
those training wheels.

1037
00:49:06,750 --> 00:49:10,110
中文字幕
It turns out that when you get a string with get_string,

1038
00:49:10,110 --> 00:49:12,660
中文字幕
it doesn't return a string, per se, because again,

1039
00:49:12,660 --> 00:49:16,620
中文字幕
that word doesn't exist in C, it actually returns a char*.

1040
00:49:16,620 --> 00:49:19,900
中文字幕
And when I call it again here and return another string, it, too,

1041
00:49:19,900 --> 00:49:21,090
中文字幕
returns a char*.

1042
00:49:21,090 --> 00:49:24,190
中文字幕
Now technically the star can have spaces around it.

1043
00:49:24,190 --> 00:49:27,420
中文字幕
Some people write it like this, but the sort of right way to do it

1044
00:49:27,420 --> 00:49:30,750
中文字幕
or the default way should just be to put the star next to the variable name

1045
00:49:30,750 --> 00:49:31,900
中文字幕
for clarity.

1046
00:49:31,900 --> 00:49:33,870
中文字幕
So I have to make a few other changes.

1047
00:49:33,870 --> 00:49:37,770
中文字幕
This should change too, because there is no more string as of today.

1048
00:49:37,770 --> 00:49:41,700
中文字幕
I'm going to change this to a char*; and then I also need to change it here,

1049
00:49:41,700 --> 00:49:48,990
中文字幕
char*; and then here, char*; and that is actually it.

1050
00:49:48,990 --> 00:49:53,640
中文字幕
And honestly, the only reason we didn't introduce this like two weeks ago

1051
00:49:53,640 --> 00:49:55,010
中文字幕
is because it just looks cryptic.

1052
00:49:55,010 --> 00:49:58,180
中文字幕
Like no one wants to program the first time they're ever touching a keyboard

1053
00:49:58,180 --> 00:50:01,230
中文字幕
and writing code and see char* and need to worry about what that means,

1054
00:50:01,230 --> 00:50:03,000
中文字幕
it's just a string conceptually.

1055
00:50:03,000 --> 00:50:06,450
中文字幕
But the only change I technically need to make to take those training wheels

1056
00:50:06,450 --> 00:50:11,130
中文字幕
off is just change all mentions of string as data types to char*.

1057
00:50:11,130 --> 00:50:12,930
中文字幕
And that just means that you know what-- a?

1058
00:50:12,930 --> 00:50:17,160
中文字幕
Yes it's a string, but more technically it's the address of a string.

1059
00:50:17,160 --> 00:50:21,720
中文字幕
Or more precisely, it is the address of the first byte of the string,

1060
00:50:21,720 --> 00:50:25,170
中文字幕
like 100 for Brian or 900 for Veronica, and I'm not even

1061
00:50:25,170 --> 00:50:28,950
中文字幕
going to tell you where the string ends because you, the programmer,

1062
00:50:28,950 --> 00:50:32,460
中文字幕
can figure that out by calling strlen or just by using a loop

1063
00:50:32,460 --> 00:50:35,550
中文字幕
and figuring out where that backslash 0 actually is.

1064
00:50:35,550 --> 00:50:37,990
中文字幕
So that is enough information to pass it around.

1065
00:50:37,990 --> 00:50:41,910
中文字幕
So if go ahead now and compile this, make compare3,

1066
00:50:41,910 --> 00:50:47,190
中文字幕
and then I go ahead and do ./compare3, let's go ahead and type in Brian

1067
00:50:47,190 --> 00:50:49,770
中文字幕
and Veronica, those are indeed still different.

1068
00:50:49,770 --> 00:50:53,660
中文字幕
Now let me go ahead and type in David and David, those are in fact the same.

1069
00:50:53,660 --> 00:50:56,370
中文字幕
So the training wheels are off, there is no such thing as string,

1070
00:50:56,370 --> 00:50:57,560
中文字幕
henceforth it's a char*.

1071
00:50:57,560 --> 00:51:00,060
中文字幕
Let's go ahead and take a quick break here for five minutes,

1072
00:51:00,060 --> 00:51:02,070
中文字幕
and we'll come back and dive in more.

1073
00:51:02,070 --> 00:51:03,240
中文字幕
All right.

1074
00:51:03,240 --> 00:51:06,630
中文字幕
So we are back, and let's go ahead and simplify this now,

1075
00:51:06,630 --> 00:51:07,710
中文字幕
as our tendency has been.

1076
00:51:07,710 --> 00:51:09,450
中文字幕
It's kind of a bunch of code, but I think

1077
00:51:09,450 --> 00:51:10,610
中文字幕
we can make this a little tighter.

1078
00:51:10,610 --> 00:51:12,430
中文字幕
But rather than type this one out manually,

1079
00:51:12,430 --> 00:51:14,850
中文字幕
let me go ahead and just open one of our pre-made examples

1080
00:51:14,850 --> 00:51:18,840
中文字幕
from today, which is all in the course's website, called compare4.

1081
00:51:18,840 --> 00:51:21,540
中文字幕
And you'll see in compare4, that's it.

1082
00:51:21,540 --> 00:51:23,670
中文字幕
I only have a main function this time.

1083
00:51:23,670 --> 00:51:26,970
中文字幕
I've gotten rid of my compare_strings function because you know what?

1084
00:51:26,970 --> 00:51:29,600
中文字幕
I seem to be using something instead.

1085
00:51:29,600 --> 00:51:33,090
中文字幕
What function did I apparently deploy?

1086
00:51:33,090 --> 00:51:35,640
中文字幕
Yeah, S-T-R-C-M-P, or someone with pronounce it,

1087
00:51:35,640 --> 00:51:37,830
中文字幕
just str compare or strcmp.

1088
00:51:37,830 --> 00:51:41,040
中文字幕
So this, like strlen, also succinctly named,

1089
00:51:41,040 --> 00:51:43,650
中文字幕
is just a function that's actually declared

1090
00:51:43,650 --> 00:51:46,980
中文字幕
in one of our familiar libraries up top, string.h,

1091
00:51:46,980 --> 00:51:49,960
中文字幕
and it turns out if you look in the man page, so to speak,

1092
00:51:49,960 --> 00:51:53,020
中文字幕
by typing man strcmp, or if you go to CS50 reference and actually

1093
00:51:53,020 --> 00:51:55,650
中文字幕
look at the less comfortable description of the function there,

1094
00:51:55,650 --> 00:51:57,730
中文字幕
this is just a function whose sole purpose in life

1095
00:51:57,730 --> 00:51:59,730
中文字幕
is to compare strings for you.

1096
00:51:59,730 --> 00:52:01,890
中文字幕
But it's a little different in behavior because it's

1097
00:52:01,890 --> 00:52:03,690
中文字幕
a little fancier than the one I just wrote.

1098
00:52:03,690 --> 00:52:07,860
中文字幕
Let me zoom in on this, and you'll see that line 14 here, I'm

1099
00:52:07,860 --> 00:52:11,490
中文字幕
not quite treating it in the same way.

1100
00:52:11,490 --> 00:52:14,840
中文字幕
My logic is ever so slightly different.

1101
00:52:14,840 --> 00:52:20,100
中文字幕
What am I actually checking for in my Boolean expression this time?

1102
00:52:21,450 --> 00:52:23,250
中文字幕
Yeah, which is a little weird.

1103
00:52:23,250 --> 00:52:28,860
中文字幕
I'm checking explicitly-- if strcmp's return value equal-equal to 0.

1104
00:52:28,860 --> 00:52:33,140
中文字幕
Before I just said, if compare_strings s comma

1105
00:52:33,140 --> 00:52:38,460
中文字幕
t, because I was expecting back a bool-- true or false. strcmp, kind of weird,

1106
00:52:38,460 --> 00:52:40,060
中文字幕
acts the opposite way.

1107
00:52:40,060 --> 00:52:43,380
中文字幕
It turns out that strcmp doesn't return true and false.

1108
00:52:43,380 --> 00:52:48,120
中文字幕
If you read its documentation, it returns 0 if the strings are equal,

1109
00:52:48,120 --> 00:52:52,120
中文字幕
but super conveniently, it returns a positive value

1110
00:52:52,120 --> 00:52:56,190
中文字幕
if s is supposed to come before t, and it returns a negative value

1111
00:52:56,190 --> 00:52:59,950
中文字幕
if s is supposed to come after t alphabetically.

1112
00:52:59,950 --> 00:53:03,270
中文字幕
So it turns out that you can use strcmp not just to compare for equality,

1113
00:53:03,270 --> 00:53:04,530
中文字幕
but inequality--

1114
00:53:04,530 --> 00:53:05,760
中文字幕
less than or equal--

1115
00:53:05,760 --> 00:53:08,880
中文字幕
less than or greater than, so to speak, alphabetically,

1116
00:53:08,880 --> 00:53:10,810
中文字幕
or in ASCII order, so to speak.

1117
00:53:10,810 --> 00:53:13,860
中文字幕
It will actually compare character by character the ASCII values,

1118
00:53:13,860 --> 00:53:16,050
中文字幕
and that will make sure that B comes after A,

1119
00:53:16,050 --> 00:53:18,430
中文字幕
and C comes after B, and so forth.

1120
00:53:18,430 --> 00:53:20,940
中文字幕
So you can actually use strcmp to like sort a dictionary,

1121
00:53:20,940 --> 00:53:24,310
中文字幕
or to sort the contacts in your iPhone or your Android phone.

1122
00:53:24,310 --> 00:53:27,090
中文字幕
So long story short, this is a function we can use,

1123
00:53:27,090 --> 00:53:30,120
中文字幕
we don't have to reinvent this wheel, and thus, we have no more code

1124
00:53:30,120 --> 00:53:30,840
中文字幕
even after this.

1125
00:53:30,840 --> 00:53:33,810
中文字幕
We just have to use it correctly, and there, the documentation

1126
00:53:33,810 --> 00:53:34,720
中文字幕
is your friend.

1127
00:53:34,720 --> 00:53:37,770
中文字幕
So if I run this program it's going to work exactly the same way,

1128
00:53:37,770 --> 00:53:40,590
中文字幕
but let me go ahead and point out some flaws.

1129
00:53:40,590 --> 00:53:44,820
中文字幕
It turns out all this time, I've been a little lazy with my error checking--

1130
00:53:44,820 --> 00:53:46,200
中文字幕
checking for errors.

1131
00:53:46,200 --> 00:53:49,630
中文字幕
There's a whole bunch of things that can go wrong in week 1 of CS50

1132
00:53:49,630 --> 00:53:52,260
中文字幕
that we just kind of turn a blind eye to, because it would just

1133
00:53:52,260 --> 00:53:56,090
中文字幕
bloat our code, make it longer and sort of less interesting and fun to write

1134
00:53:56,090 --> 00:53:57,090
中文字幕
and less comprehensible.

1135
00:53:57,090 --> 00:53:59,770
中文字幕
But today, now that we know what's actually going on,

1136
00:53:59,770 --> 00:54:01,650
中文字幕
we can begin to ask some additional questions

1137
00:54:01,650 --> 00:54:04,020
中文字幕
and make our code stronger, more robust so

1138
00:54:04,020 --> 00:54:05,820
中文字幕
that nothing does, in fact, go wrong.

1139
00:54:05,820 --> 00:54:08,940
中文字幕
Turns out, if you read the documentation for get_string in the man page

1140
00:54:08,940 --> 00:54:11,880
中文字幕
or in CS50 reference, turns out get_string

1141
00:54:11,880 --> 00:54:14,010
中文字幕
does return a string-- uh, not really.

1142
00:54:14,010 --> 00:54:15,690
中文字幕
It returns the address of a string.

1143
00:54:15,690 --> 00:54:16,380
中文字幕
Uh, not really.

1144
00:54:16,380 --> 00:54:22,230
中文字幕
It returns the address of the first byte of a string, technically.

1145
00:54:22,230 --> 00:54:26,700
中文字幕
But if something goes wrong, it returns a special character called null.

1146
00:54:26,700 --> 00:54:32,230
中文字幕
Not to be confused with NUL, it returns a special address called null--

1147
00:54:32,230 --> 00:54:34,510
中文字幕
left hand wasn't talking to right hand decades ago.

1148
00:54:34,510 --> 00:54:41,100
中文字幕
So null, N-U-L-L, just means the address 0, which nothing should ever live at.

1149
00:54:41,100 --> 00:54:44,190
中文字幕
It's just a bogus, invalid address.

1150
00:54:44,190 --> 00:54:49,200
中文字幕
Insofar as get_string returns the address of a string in memory,

1151
00:54:49,200 --> 00:54:53,760
中文字幕
like 100 for Brian or 900 for Veronica, if get_string ever

1152
00:54:53,760 --> 00:54:56,640
中文字幕
runs into a problem and just something goes wrong with the computer,

1153
00:54:56,640 --> 00:55:01,830
中文字幕
if it ever returns 0, specifically 0, a.k.a.

1154
00:55:01,830 --> 00:55:07,470
中文字幕
null-- N-U-L-L, then you can detect that something has gone wrong.

1155
00:55:07,470 --> 00:55:10,080
中文字幕
So to do that, and it's going to get a little tedious,

1156
00:55:10,080 --> 00:55:11,880
中文字幕
but it's nonetheless the right thing to do,

1157
00:55:11,880 --> 00:55:14,430
中文字幕
I need to be a little more defensive.

1158
00:55:14,430 --> 00:55:21,270
中文字幕
If s equals-equals null, otherwise known as 0, otherwise known as 0x0,

1159
00:55:21,270 --> 00:55:23,160
中文字幕
but I'll write it conventionally like this,

1160
00:55:23,160 --> 00:55:27,270
中文字幕
I'm going to go ahead and return 1 as my exit code.

1161
00:55:27,270 --> 00:55:32,370
中文字幕
If t equals-equals null, I'm going to go ahead and return 1 as my exit code,

1162
00:55:32,370 --> 00:55:34,140
中文字幕
or I could return 2 or 3--

1163
00:55:34,140 --> 00:55:36,950
中文字幕
I just need to return some value to signal to the computer

1164
00:55:36,950 --> 00:55:38,910
中文字幕
that something went wrong, but by default we'll

1165
00:55:38,910 --> 00:55:43,410
中文字幕
just return 1 whenever something goes wrong, but if all went well,

1166
00:55:43,410 --> 00:55:44,910
中文字幕
I'm going to go ahead and return 0.

1167
00:55:44,910 --> 00:55:47,580
中文字幕
So recall again from last week, and we didn't spend a huge amount of time

1168
00:55:47,580 --> 00:55:48,300
中文字幕
on this--

1169
00:55:48,300 --> 00:55:50,340
中文字幕
main itself can return values.

1170
00:55:50,340 --> 00:55:53,790
中文字幕
By default, ever since week 1, if you don't return anything,

1171
00:55:53,790 --> 00:55:58,200
中文字幕
main is automatically and secretly returning 0 for you because 0 is good.

1172
00:55:58,200 --> 00:56:02,070
中文字幕
The reason for 0 is because there's only one 0 in the world, obviously,

1173
00:56:02,070 --> 00:56:03,870
中文字幕
but there is an infinite number to the left

1174
00:56:03,870 --> 00:56:06,900
中文字幕
and there's an infinite number of the right, negative and positive.

1175
00:56:06,900 --> 00:56:09,340
中文字幕
That's great, because as you've already experienced in the past few weeks,

1176
00:56:09,340 --> 00:56:11,640
中文字幕
it feels like there's an infinite number of things that can go wrong when you're

1177
00:56:11,640 --> 00:56:13,410
中文字幕
writing even the shortest of programs.

1178
00:56:13,410 --> 00:56:17,190
中文字幕
So that means we have a lot of numbers we can assign to error codes,

1179
00:56:17,190 --> 00:56:18,250
中文字幕
so to speak.

1180
00:56:18,250 --> 00:56:20,670
中文字幕
Now I don't really care what the error codes are,

1181
00:56:20,670 --> 00:56:23,340
中文字幕
so I'm just going to adopt the human convention at the moment--

1182
00:56:23,340 --> 00:56:27,480
中文字幕
if anything goes wrong, returns anything other than 0.

1183
00:56:27,480 --> 00:56:31,650
中文字幕
And so I'm going to return 1 up here, but if nothing goes wrong, return 0.

1184
00:56:31,650 --> 00:56:36,720
中文字幕
The point here is that by adding these three lines here and these three

1185
00:56:36,720 --> 00:56:38,790
中文字幕
lines here, I'm going to avoid what's called

1186
00:56:38,790 --> 00:56:42,210
中文字幕
a segmentation fault or segfault. Did any of you

1187
00:56:42,210 --> 00:56:43,590
中文字幕
encounter this cryptic error?

1188
00:56:43,590 --> 00:56:44,130
中文字幕
OK.

1189
00:56:44,130 --> 00:56:46,920
中文字幕
So a decent number of you, and if you probably had no idea what that means,

1190
00:56:46,920 --> 00:56:49,380
中文字幕
but starting today you will a bit more, and in the weeks to come,

1191
00:56:49,380 --> 00:56:50,790
中文字幕
you'll understand even more.

1192
00:56:50,790 --> 00:56:54,690
中文字幕
Segmentation fault means you touched memory you should not have.

1193
00:56:54,690 --> 00:56:58,050
中文字幕
Or something went wrong and you did not detect it.

1194
00:56:58,050 --> 00:57:01,320
中文字幕
It's kind of a catch-all phrase for memory-related problems.

1195
00:57:01,320 --> 00:57:03,960
中文字幕
This helps ward off those kinds of errors.

1196
00:57:03,960 --> 00:57:06,690
中文字幕
It's not the only way, but it's one such way.

1197
00:57:06,690 --> 00:57:09,330
中文字幕
So starting today with problems set programs and anything

1198
00:57:09,330 --> 00:57:12,090
中文字幕
you write in the course, you always want to be thinking about,

1199
00:57:12,090 --> 00:57:14,640
中文字幕
even if you go back and add it later, could this go wrong?

1200
00:57:14,640 --> 00:57:16,310
中文字幕
Could this go wrong?

1201
00:57:16,310 --> 00:57:18,190
中文字幕
And just add some additional ifs and else-ifs

1202
00:57:18,190 --> 00:57:21,280
中文字幕
and handle those situations so that your program doesn't just crash on you

1203
00:57:21,280 --> 00:57:25,260
中文字幕
or segfault or surprise someone who's actually using it.

1204
00:57:25,260 --> 00:57:28,410
中文字幕
All right, let's take a look at one final example,

1205
00:57:28,410 --> 00:57:30,300
中文字幕
because frankly this is a little tedious.

1206
00:57:30,300 --> 00:57:32,110
中文字幕
I'm going to go ahead and open up--

1207
00:57:32,110 --> 00:57:34,590
中文字幕
and this file can be found in compare5.c.

1208
00:57:34,590 --> 00:57:39,120
中文字幕
Let me go ahead and save this so that we have it-- compare5.c.

1209
00:57:39,120 --> 00:57:41,090
中文字幕
I'm going to make one final comparison example.

1210
00:57:41,090 --> 00:57:43,800
中文字幕
I'm going to save this as compare6.c.

1211
00:57:43,800 --> 00:57:46,020
中文字幕
Turns out that humans like their succinctness.

1212
00:57:46,020 --> 00:57:50,890
中文字幕
And null, because it is technically the 0 address,

1213
00:57:50,890 --> 00:57:52,920
中文字幕
you can actually be a little clever.

1214
00:57:52,920 --> 00:57:59,430
中文字幕
If not s and if not t is a sufficient way to express those same things.

1215
00:57:59,430 --> 00:58:00,960
中文字幕
Because what does the bang do?

1216
00:58:00,960 --> 00:58:04,050
中文字幕
The exclamation point in code if you recall?

1217
00:58:04,050 --> 00:58:05,170
中文字幕
It inverts something.

1218
00:58:05,170 --> 00:58:11,720
中文字幕
So like if this is saying, if s is not 0, a.k.a., if s not null, or rather--

1219
00:58:15,210 --> 00:58:18,000
中文字幕
if-- now I'm getting confused.

1220
00:58:18,000 --> 00:58:18,500
中文字幕
Yes.

1221
00:58:18,500 --> 00:58:21,910
中文字幕
If I had just said, if s, then it's a valid address

1222
00:58:21,910 --> 00:58:23,750
中文字幕
and I should go on with my business.

1223
00:58:23,750 --> 00:58:28,300
中文字幕
But if it's not s or if s is null, I want

1224
00:58:28,300 --> 00:58:31,240
中文字幕
to go ahead and return 1 because there's an error, and down here too.

1225
00:58:31,240 --> 00:58:33,910
中文字幕
So any time you're checking whether something equals null,

1226
00:58:33,910 --> 00:58:37,390
中文字幕
you can make it more succinct by just saying if not s; if it's null,

1227
00:58:37,390 --> 00:58:38,020
中文字幕
return 1.

1228
00:58:38,020 --> 00:58:39,190
中文字幕
If it's null, return 1.

1229
00:58:39,190 --> 00:58:42,680
中文字幕
It's just syntactic shorthand.

1230
00:58:42,680 --> 00:58:43,180
中文字幕
Phew!

1231
00:58:43,180 --> 00:58:45,100
中文字幕
I had to think about that one.

1232
00:58:45,100 --> 00:58:45,820
中文字幕
Any questions?

1233
00:58:45,820 --> 00:58:53,160
中文字幕
Why does [INAUDIBLE] will store some [INAUDIBLE]

1234
00:58:53,160 --> 00:58:54,280
中文字幕
Correct.

1235
00:58:54,280 --> 00:58:58,020
中文字幕
You are storing an address, but if that address is 0.

1236
00:58:58,020 --> 00:59:04,300
中文字幕
Saying if it's not 0, 0 is like false, so not false means true,

1237
00:59:04,300 --> 00:59:07,990
中文字幕
and so it has the effect of inverting the logic.

1238
00:59:07,990 --> 00:59:08,590
中文字幕
That's all.

1239
00:59:08,590 --> 00:59:12,570
中文字幕
Anytime you use a bang or exclamation point, it changes a 0 to non-0--

1240
00:59:12,570 --> 00:59:14,950
中文字幕
, but even--

1241
00:59:14,950 --> 00:59:20,820
中文字幕
I don't understand why [INAUDIBLE] implies that it's [INAUDIBLE]..

1242
00:59:20,820 --> 00:59:22,820
中文字幕
So you can think about it this way.

1243
00:59:22,820 --> 00:59:24,720
中文字幕
If s-- previously we had this.

1244
00:59:24,720 --> 00:59:30,350
中文字幕
If s equals-equals null is like saying if s literally equals 0.

1245
00:59:30,350 --> 00:59:32,480
中文字幕
And you can kind of think of that informally as

1246
00:59:32,480 --> 00:59:34,970
中文字幕
if s doesn't have a valid pointer--

1247
00:59:34,970 --> 00:59:38,110
中文字幕
0 is not a valid point or it's not a valid address by definition.

1248
00:59:38,110 --> 00:59:42,450
中文字幕
100 is valid, 900 is valid, 0 is not valid just by a human convention.

1249
00:59:42,450 --> 00:59:46,680
中文字幕
So this is like saying, if s does not have a value, that's valid.

1250
00:59:46,680 --> 00:59:52,130
中文字幕
So the way to succinctly say that, if not s,

1251
00:59:52,130 --> 00:59:55,040
中文字幕
and it's just shorthand for that is another way to think about it.

1252
00:59:55,040 --> 00:59:58,270
中文字幕
All right, so let's take a look at a very different program,

1253
00:59:58,270 --> 01:00:02,070
中文字幕
but that reveals the same kind of issue as follows.

1254
01:00:02,070 --> 01:00:05,030
中文字幕
I'm going to go ahead and open up an example called

1255
01:00:05,030 --> 01:00:09,410
中文字幕
copy0, whose purpose in life hopefully is to copy a string.

1256
01:00:09,410 --> 01:00:11,690
中文字幕
So notice that in my program here, which I

1257
01:00:11,690 --> 01:00:15,440
中文字幕
wrote in advance, I'm getting a string from the user on line 11,

1258
01:00:15,440 --> 01:00:17,240
中文字幕
and I'm storing it in a string called s.

1259
01:00:17,240 --> 01:00:20,210
中文字幕
I could change this to char* now, but we know what it is.

1260
01:00:20,210 --> 01:00:24,560
中文字幕
And I'm going to go ahead and copy the string's address from s into t.

1261
01:00:24,560 --> 01:00:29,370
中文字幕
And then I'm going to say, if the length of t is greater than 0,

1262
01:00:29,370 --> 01:00:31,620
中文字幕
then go ahead and just capitalize the first character.

1263
01:00:31,620 --> 01:00:32,660
中文字幕
So it's a little cryptic, but you might have

1264
01:00:32,660 --> 01:00:35,120
中文字幕
done something kind of like this with Caesar and with recent string

1265
01:00:35,120 --> 01:00:35,930
中文字幕
manipulation.

1266
01:00:35,930 --> 01:00:38,810
中文字幕
This is just making sure, do I have at least one character?

1267
01:00:38,810 --> 01:00:42,340
中文字幕
And if so, first character is t bracket 0, as you recall.

1268
01:00:42,340 --> 01:00:45,550
中文字幕
toupper is a function in ctype.h from last week

1269
01:00:45,550 --> 01:00:46,970
中文字幕
that just capitalizes this letter.

1270
01:00:46,970 --> 01:00:50,060
中文字幕
So this one line of code, 19, just capitalizes the first letter

1271
01:00:50,060 --> 01:00:51,230
中文字幕
in t, that's it.

1272
01:00:51,230 --> 01:00:54,440
中文字幕
And then at the very end we just print out what s is and print out what t is.

1273
01:00:54,440 --> 01:00:55,010
中文字幕
That's all.

1274
01:00:55,010 --> 01:00:59,390
中文字幕
So this program just copies s into t, capitalizes t, and that's it.

1275
01:00:59,390 --> 01:01:02,330
中文字幕
So let me go ahead and make copy0.

1276
01:01:02,330 --> 01:01:03,630
中文字幕
This is in our code from today.

1277
01:01:03,630 --> 01:01:07,340
中文字幕
So I'm going to do cd sc3, because I already wrote it in that directory.

1278
01:01:07,340 --> 01:01:08,970
中文字幕
make copy0.

1279
01:01:08,970 --> 01:01:12,810
中文字幕
Went well. ./copy0.

1280
01:01:12,810 --> 01:01:17,240
中文字幕
Let's go ahead and type in tj again in lowercase.

1281
01:01:17,240 --> 01:01:18,270
中文字幕
Enter.

1282
01:01:18,270 --> 01:01:19,760
中文字幕
Huh.

1283
01:01:19,760 --> 01:01:21,930
中文字幕
TJ, TJ-- both are capitalized.

1284
01:01:21,930 --> 01:01:24,230
中文字幕
All right, maybe it's just a weird thing with initials.

1285
01:01:24,230 --> 01:01:28,520
中文字幕
So let's just do Veronica, all lowercase.

1286
01:01:28,520 --> 01:01:30,140
中文字幕
Huh, that's definitely capital.

1287
01:01:30,140 --> 01:01:32,720
中文字幕
Let's do even more obvious difference, Brian where

1288
01:01:32,720 --> 01:01:35,070
中文字幕
the B's really going to look different.

1289
01:01:35,070 --> 01:01:38,270
中文字幕
Yet I'm only capitalizing t.

1290
01:01:38,270 --> 01:01:40,580
中文字幕
Well let's consider what's actually going on here.

1291
01:01:40,580 --> 01:01:46,080
中文字幕
In this case, when I'm getting a string from the user, s and t, and I type in,

1292
01:01:46,080 --> 01:01:51,020
中文字幕
for instance, brian in all lowercase, backslash 0, this, of course,

1293
01:01:51,020 --> 01:01:54,710
中文字幕
is just an array underneath the hood.

1294
01:01:54,710 --> 01:01:56,150
中文字幕
This is taking up six bytes here.

1295
01:01:56,150 --> 01:01:58,920
中文字幕
And when I store in s, s is a string.

1296
01:01:58,920 --> 01:01:59,630
中文字幕
So you know what?

1297
01:01:59,630 --> 01:02:00,670
中文字幕
We didn't do this before.

1298
01:02:00,670 --> 01:02:05,300
中文字幕
Let me actually create a variable, a chunk of memory for s and call it s.

1299
01:02:05,300 --> 01:02:07,760
中文字幕
And suppose Brian is just where he was before--

1300
01:02:07,760 --> 01:02:13,230
中文字幕
100, 101, 102, 103, 104, and 105.

1301
01:02:13,230 --> 01:02:18,110
中文字幕
So if I do s equals get_string and get_string returns Brian,

1302
01:02:18,110 --> 01:02:21,620
中文字幕
what do I write in the box called s?

1303
01:02:21,620 --> 01:02:22,820
中文字幕
Yeah, just 100, right?

1304
01:02:22,820 --> 01:02:24,780
中文字幕
This is all that's been going on all this time

1305
01:02:24,780 --> 01:02:27,050
中文字幕
even though we didn't talk about it at this level.

1306
01:02:27,050 --> 01:02:30,920
中文字幕
And actually, it turns out-- pointer actually can be used pictorially.

1307
01:02:30,920 --> 01:02:34,940
中文字幕
If you actually prefer to think about a pointer as being an address

1308
01:02:34,940 --> 01:02:37,950
中文字幕
or like kind of a map that leads you somewhere, another way a human

1309
01:02:37,950 --> 01:02:40,040
中文字幕
would typically draw a pointer-- because honestly,

1310
01:02:40,040 --> 01:02:41,960
中文字幕
who really cares that Brian is at address 100?

1311
01:02:41,960 --> 01:02:45,230
中文字幕
Like that is way too low level, that's week 0 stuff.

1312
01:02:45,230 --> 01:02:46,820
中文字幕
He's just pointing there.

1313
01:02:46,820 --> 01:02:49,190
中文字幕
So s is a pointer to that chunk of memory.

1314
01:02:49,190 --> 01:02:52,640
中文字幕
It happens to be 100, whatever, the arrow is how you would literally

1315
01:02:52,640 --> 01:02:56,060
中文字幕
point at the chunk of memory if you were drawing this on some notes.

1316
01:02:56,060 --> 01:02:57,710
中文字幕
So that, too, is correct.

1317
01:02:57,710 --> 01:03:00,980
中文字幕
So the problem arises here with that line of code.

1318
01:03:00,980 --> 01:03:07,280
中文字幕
When I actually try to copy s and store in t, think about what's going on.

1319
01:03:07,280 --> 01:03:10,830
中文字幕
The right-hand side is just s's value, which happens to be 100.

1320
01:03:10,830 --> 01:03:13,460
中文字幕
The left-hand side is just saying, hey computer, give me

1321
01:03:13,460 --> 01:03:16,760
中文字幕
another variable, first string, and call it t.

1322
01:03:16,760 --> 01:03:19,730
中文字幕
So that's like saying, hey, computer, give me another chunk of memory,

1323
01:03:19,730 --> 01:03:22,760
中文字幕
call it t, and then store s in it.

1324
01:03:22,760 --> 01:03:24,140
中文字幕
But what does it mean to store s?

1325
01:03:24,140 --> 01:03:27,800
中文字幕
Well what is s's value at this point in time?

1326
01:03:27,800 --> 01:03:30,140
中文字幕
It's the pointer to Brian, or it's technically--

1327
01:03:30,140 --> 01:03:34,000
中文字幕
I'll write both just for thoroughness-- it's literally the number 100.

1328
01:03:34,000 --> 01:03:39,720
中文字幕
So if you do t equals s, that is like saying put 100 there too,

1329
01:03:39,720 --> 01:03:42,580
中文字幕
and pictorially that's like saying this.

1330
01:03:42,580 --> 01:03:46,860
中文字幕
So at this point in the story, when I copy s into t,

1331
01:03:46,860 --> 01:03:48,540
中文字幕
the computer took me literally.

1332
01:03:48,540 --> 01:03:51,390
中文字幕
It did copy s into t, but what is s?

1333
01:03:51,390 --> 01:03:52,470
中文字幕
It's just the address.

1334
01:03:52,470 --> 01:03:56,800
中文字幕
It is not B-R-I-A-N backslash 0, it's just the address.

1335
01:03:56,800 --> 01:04:00,810
中文字幕
So when I then say, t bracket 0 gets toupper--

1336
01:04:00,810 --> 01:04:02,370
中文字幕
so let's look at this line of code.

1337
01:04:02,370 --> 01:04:04,590
中文字幕
The one line of code here that's highlighted,

1338
01:04:04,590 --> 01:04:07,740
中文字幕
when I say go to the 0th character of t and store

1339
01:04:07,740 --> 01:04:11,960
中文字幕
the uppercase version of that same character, you just follow the arrows.

1340
01:04:11,960 --> 01:04:13,920
中文字幕
If you ever played chutes and ladders as a kid,

1341
01:04:13,920 --> 01:04:16,250
中文字幕
you just kind of follow the arrow, see where you end up.

1342
01:04:16,250 --> 01:04:19,750
中文字幕
t bracket 0 is this location here, because again,

1343
01:04:19,750 --> 01:04:22,330
中文字幕
if this is a chunk of memory, per last week it's an array,

1344
01:04:22,330 --> 01:04:26,580
中文字幕
so you can also think of this as being bracket 0, this is bracket 1,

1345
01:04:26,580 --> 01:04:30,460
中文字幕
this is bracket 2, and so forth.

1346
01:04:30,460 --> 01:04:31,600
中文字幕
So it's just an array.

1347
01:04:31,600 --> 01:04:36,810
中文字幕
So t bracket 0 is lowercase b, and toupper of lowercase b,

1348
01:04:36,810 --> 01:04:40,650
中文字幕
of course, changes this little b to a B. But now

1349
01:04:40,650 --> 01:04:43,220
中文字幕
both s and t are still pointing at the same chunk of memory,

1350
01:04:43,220 --> 01:04:47,620
中文字幕
so of course s and t are both going to be Bryan capitalized,

1351
01:04:47,620 --> 01:04:51,000
中文字幕
or TJ too in my first example.

1352
01:04:51,000 --> 01:04:57,260
中文字幕
Any questions then on what we just did and why that happens?

1353
01:04:57,260 --> 01:04:59,100
中文字幕
All right, so intuitively what's the fix?

1354
01:04:59,100 --> 01:05:01,100
中文字幕
Doesn't matter if you've no idea how to code it,

1355
01:05:01,100 --> 01:05:04,880
中文字幕
like what do we have to do to fundamentally copy a string, not

1356
01:05:04,880 --> 01:05:06,570
中文字幕
an address?

1357
01:05:08,830 --> 01:05:10,130
中文字幕
Create a new what?

1358
01:05:10,130 --> 01:05:12,500
中文字幕
AUDIENCE: Basically create the [INAUDIBLE]..

1359
01:05:12,500 --> 01:05:13,250
中文字幕
Yeah.

1360
01:05:13,250 --> 01:05:15,240
中文字幕
Create the same string in a new chunk of memory.

1361
01:05:15,240 --> 01:05:17,970
中文字幕
What I really need to do is allocate or give myself

1362
01:05:17,970 --> 01:05:21,720
中文字幕
a bunch of more memory that's just as big as Brian,

1363
01:05:21,720 --> 01:05:24,750
中文字幕
including his backslash 0.

1364
01:05:24,750 --> 01:05:28,450
中文字幕
And then logically I just need to copy every character into that.

1365
01:05:28,450 --> 01:05:31,020
中文字幕
So if I go back to my original when it was a lowercase b,

1366
01:05:31,020 --> 01:05:34,080
中文字幕
I need to make a copy logically by using a for loop or a while loop

1367
01:05:34,080 --> 01:05:35,130
中文字幕
or whatever you prefer--

1368
01:05:35,130 --> 01:05:42,990
中文字幕
B-R-I-A-N backslash 0, so that when I copy the string and then store it in t,

1369
01:05:42,990 --> 01:05:45,480
中文字幕
It's not actually copying literally s.

1370
01:05:45,480 --> 01:05:49,540
中文字幕
And let's suppose that he ends up at location 300 just arbitrarily--

1371
01:05:49,540 --> 01:05:51,010
中文字幕
just making up easy numbers.

1372
01:05:51,010 --> 01:05:54,780
中文字幕
t now stores 300, points here.

1373
01:05:54,780 --> 01:05:59,370
中文字幕
So when I execute this line in this version of the story, t bracket 0

1374
01:05:59,370 --> 01:06:02,250
中文字幕
gets toupper, what am I actually doing?

1375
01:06:02,250 --> 01:06:04,440
中文字幕
I'm following a different arrow this time

1376
01:06:04,440 --> 01:06:08,280
中文字幕
because I gave myself a different chunk of memory, capitalizing this Brian,

1377
01:06:08,280 --> 01:06:13,170
中文字幕
thereby hopefully fixing the bug, albeit verbally only.

1378
01:06:13,170 --> 01:06:14,910
中文字幕
So how do we do this in code?

1379
01:06:14,910 --> 01:06:16,300
中文字幕
We need to do exactly that.

1380
01:06:16,300 --> 01:06:18,400
中文字幕
We need to give ourself some more memory,

1381
01:06:18,400 --> 01:06:23,830
中文字幕
so let's introduce one other feature of C. In copy1.c,

1382
01:06:23,830 --> 01:06:25,930
中文字幕
we see the solution to this problem.

1383
01:06:25,930 --> 01:06:31,260
中文字幕
Notice at the top I'm doing things a little lower level-- oop, surprise.

1384
01:06:31,260 --> 01:06:33,740
中文字幕
Notice in this version of the code, copy1.c,

1385
01:06:33,740 --> 01:06:37,950
中文字幕
see I've started off almost the same, but just to be super clear,

1386
01:06:37,950 --> 01:06:39,180
中文字幕
I'm just using char*.

1387
01:06:39,180 --> 01:06:41,050
中文字幕
I don't want any magic, so there's no string,

1388
01:06:41,050 --> 01:06:42,390
中文字幕
there's no training wheels here.

1389
01:06:42,390 --> 01:06:45,300
中文字幕
But this logically is the exact same as before--

1390
01:06:45,300 --> 01:06:46,800
中文字幕
plus the error-checking.

1391
01:06:46,800 --> 01:06:47,850
中文字幕
This line is new.

1392
01:06:47,850 --> 01:06:51,760
中文字幕
And it looks a little funky, but let's see what's going on.

1393
01:06:51,760 --> 01:06:54,510
中文字幕
And this line of code here, what am I doing?

1394
01:06:54,510 --> 01:06:57,510
中文字幕
The left-hand side, that's shorter, let's start with the easier one.

1395
01:06:57,510 --> 01:07:02,780
中文字幕
Char* t, just in layman's terms, what does that expression do? char*?

1396
01:07:02,780 --> 01:07:06,700
中文字幕
Hey computer, do what?

1397
01:07:06,700 --> 01:07:07,320
中文字幕
What's that?

1398
01:07:08,200 --> 01:07:09,320
中文字幕
Not quite yet.

1399
01:07:09,320 --> 01:07:10,550
中文字幕
Different formulation.

1400
01:07:14,140 --> 01:07:17,110
中文字幕
Hey computer, give me--

1401
01:07:17,110 --> 01:07:17,960
中文字幕
not quite.

1402
01:07:17,960 --> 01:07:19,950
中文字幕
Be more precise?

1403
01:07:19,950 --> 01:07:21,390
中文字幕
AUDIENCE: An array?

1404
01:07:21,390 --> 01:07:23,390
中文字幕
Not quite an array, just this part.

1405
01:07:23,390 --> 01:07:25,520
中文字幕
So let me hide all this.

1406
01:07:25,520 --> 01:07:27,480
中文字幕
If the star wasn't there--

1407
01:07:27,480 --> 01:07:28,860
中文字幕
I can't really do this very well.

1408
01:07:28,860 --> 01:07:29,960
中文字幕
So this-- yeah?

1409
01:07:29,960 --> 01:07:31,900
中文字幕
character?

1410
01:07:31,900 --> 01:07:33,310
中文字幕
Good, I'll take that.

1411
01:07:33,310 --> 01:07:35,560
中文字幕
So hey computer, give me a pointer to a character.

1412
01:07:35,560 --> 01:07:37,960
中文字幕
Or even more low level, hey computer, give me

1413
01:07:37,960 --> 01:07:41,590
中文字幕
a chunk of memory in which I can store the address of a character.

1414
01:07:41,590 --> 01:07:42,820
中文字幕
I mean, it is that mundane.

1415
01:07:42,820 --> 01:07:46,000
中文字幕
Draw a box on the screen, call it s-- or rather,

1416
01:07:46,000 --> 01:07:49,820
中文字幕
call it t, but just give me space for a pointer, as you said.

1417
01:07:49,820 --> 01:07:50,950
中文字幕
So that's all that's doing.

1418
01:07:50,950 --> 01:07:54,310
中文字幕
It's drawing a box on the screen and calling it t, and it's currently empty.

1419
01:07:54,310 --> 01:07:56,920
中文字幕
Now let's look at the scarier part on the right-hand side.

1420
01:07:56,920 --> 01:07:58,780
中文字幕
malloc, new function today.

1421
01:07:58,780 --> 01:08:00,420
中文字幕
Stands for memory allocates.

1422
01:08:00,420 --> 01:08:03,420
中文字幕
It's very cryptic-sounding, but it just means give me a chunk of memory.

1423
01:08:03,420 --> 01:08:05,800
中文字幕
It says exactly what you said in functional terms.

1424
01:08:05,800 --> 01:08:07,990
中文字幕
Then it just needs you to answer one question--

1425
01:08:07,990 --> 01:08:09,610
中文字幕
OK, how much memory do you want?

1426
01:08:09,610 --> 01:08:11,290
中文字幕
How many bytes do you want?

1427
01:08:11,290 --> 01:08:15,250
中文字幕
And now maybe the math, even though cryptic at first glance, makes sense.

1428
01:08:15,250 --> 01:08:19,680
中文字幕
Get the string length of s, add 1, and then multiply it

1429
01:08:19,680 --> 01:08:21,130
中文字幕
by the size of a character.

1430
01:08:21,130 --> 01:08:23,590
中文字幕
And we've not seen this before. sizeof literally does that.

1431
01:08:23,590 --> 01:08:26,170
中文字幕
It tells you how many bytes is a char.

1432
01:08:26,170 --> 01:08:28,300
中文字幕
Happens to be 1, and in fact, that's defined.

1433
01:08:28,300 --> 01:08:32,640
中文字幕
So if we simplify this in C, the char is always 1 byte,

1434
01:08:32,640 --> 01:08:35,020
中文字幕
so this is equivalent to just multiplying by 1.

1435
01:08:35,020 --> 01:08:37,350
中文字幕
And obviously mathematically that's a waste of time,

1436
01:08:37,350 --> 01:08:39,310
中文字幕
so we can whittle this down to be even simpler.

1437
01:08:39,310 --> 01:08:41,120
中文字幕
I was just being thorough.

1438
01:08:41,120 --> 01:08:45,430
中文字幕
So now, hey computer, allocate me this many bytes of memory.

1439
01:08:45,430 --> 01:08:46,790
中文字幕
Why is it plus 1?

1440
01:08:46,790 --> 01:08:48,470
中文字幕
AUDIENCE: You need the null character.

1441
01:08:48,470 --> 01:08:50,130
中文字幕
I need that null character.

1442
01:08:50,130 --> 01:08:54,310
中文字幕
Brian is 1, 2, 3, 4, 5 as he said, but I need the sixth for his null character,

1443
01:08:54,310 --> 01:08:56,060
中文字幕
and I just know that's going to be there.

1444
01:08:56,060 --> 01:08:59,710
中文字幕
So at this point in the story, what has happened?

1445
01:08:59,710 --> 01:09:04,300
中文字幕
All that malloc does is it gives me this box of memory

1446
01:09:04,300 --> 01:09:07,860
中文字幕
containing room for as many bytes are in Brian's name.

1447
01:09:07,860 --> 01:09:09,270
中文字幕
But it doesn't fill them just yet.

1448
01:09:09,270 --> 01:09:13,160
中文字幕
Now I need to logically fill those bytes with Brian's actual name.

1449
01:09:13,160 --> 01:09:15,550
中文字幕
So if we scroll down to my for loop here,

1450
01:09:15,550 --> 01:09:18,490
中文字幕
we can actually copy the string into that space.

1451
01:09:18,490 --> 01:09:21,700
中文字幕
And it's a little long, the expression, but nothing new here.

1452
01:09:21,700 --> 01:09:28,680
中文字幕
Initialize i to 0, n to the length of s, i is less than or equal to n--

1453
01:09:28,680 --> 01:09:30,160
中文字幕
we'll come back to that, i++.

1454
01:09:30,160 --> 01:09:32,260
中文字幕
So it's just a pretty standard for loop.

1455
01:09:32,260 --> 01:09:36,490
中文字幕
Then copy the i-th character of s into the i-th character of t.

1456
01:09:36,490 --> 01:09:40,660
中文字幕
The only thing that's making me a little nervous honestly is this thing here.

1457
01:09:40,660 --> 01:09:43,000
中文字幕
Like I feel like every time we do less than or equal to,

1458
01:09:43,000 --> 01:09:45,250
中文字幕
we create a bug like last week.

1459
01:09:45,250 --> 01:09:46,480
中文字幕
But this is correct, why?

1460
01:09:50,770 --> 01:09:54,580
中文字幕
Why do I want to go up to and through the length of this?

1461
01:09:54,580 --> 01:09:56,790
中文字幕
AUDIENCE: Is it the null character that adds--

1462
01:09:56,790 --> 01:09:57,360
中文字幕
Exactly.

1463
01:09:57,360 --> 01:09:58,610
中文字幕
Because of the null character.

1464
01:09:58,610 --> 01:10:02,130
中文字幕
I actually don't want to stop at the strlen of s, so I could change this.

1465
01:10:02,130 --> 01:10:04,890
中文字幕
If you're just more comfortable using less than, because you just

1466
01:10:04,890 --> 01:10:08,460
中文字幕
got your mind wrapped around why we do that in the first place, that's fine,

1467
01:10:08,460 --> 01:10:11,440
中文字幕
we just need to do this instead.

1468
01:10:11,440 --> 01:10:16,020
中文字幕
So this is mathematically-- if you go to strlen plus 1, the same thing

1469
01:10:16,020 --> 01:10:18,780
中文字幕
as not doing that math but just going one step further.

1470
01:10:18,780 --> 01:10:20,830
中文字幕
Just whatever you want to think about it is fine.

1471
01:10:20,830 --> 01:10:22,620
中文字幕
However you want to think about it is fine.

1472
01:10:22,620 --> 01:10:25,020
中文字幕
OK, and then lastly, just a quick check, is the length

1473
01:10:25,020 --> 01:10:27,420
中文字幕
of t at least one or more characters?

1474
01:10:27,420 --> 01:10:29,910
中文字幕
Because otherwise there's nothing to capitalize, and if so,

1475
01:10:29,910 --> 01:10:31,120
中文字幕
go ahead and do it.

1476
01:10:31,120 --> 01:10:34,350
中文字幕
So if I now run this example, make-- oop, let me save it.

1477
01:10:34,350 --> 01:10:37,040
中文字幕
make copy1, that compiled.

1478
01:10:37,040 --> 01:10:42,480
中文字幕
./copy1, now let's type in tj, tj in lowercase comes back,

1479
01:10:42,480 --> 01:10:44,490
中文字幕
but now t is capitalized.

1480
01:10:44,490 --> 01:10:49,140
中文字幕
And let's go ahead and do Brian's name in all lowercase, only one of them

1481
01:10:49,140 --> 01:10:51,100
中文字幕
is now capitalized.

1482
01:10:51,100 --> 01:10:54,450
中文字幕
So does that make sense what's now happened?

1483
01:10:54,450 --> 01:10:54,950
中文字幕
All right.

1484
01:10:54,950 --> 01:10:57,980
中文字幕
So where can we go with this?

1485
01:10:57,980 --> 01:11:00,640
中文字幕
Well it turns out-- let me open up one final example here,

1486
01:11:00,640 --> 01:11:02,480
中文字幕
because honestly, that's incredibly tedious,

1487
01:11:02,480 --> 01:11:04,010
中文字幕
and no one's ever going to want to copy strings if you

1488
01:11:04,010 --> 01:11:05,510
中文字幕
have to go through all of that work.

1489
01:11:05,510 --> 01:11:08,990
中文字幕
Turns out that store copy exists.

1490
01:11:08,990 --> 01:11:11,060
中文字幕
So when in doubt, check the man page.

1491
01:11:11,060 --> 01:11:12,710
中文字幕
When in doubt, check CS50 reference.

1492
01:11:12,710 --> 01:11:15,190
中文字幕
Does the function exist somewhere related

1493
01:11:15,190 --> 01:11:16,610
中文字幕
to some keywords you have in mind?

1494
01:11:16,610 --> 01:11:18,650
中文字幕
Like string copy, see if something comes back.

1495
01:11:18,650 --> 01:11:22,490
中文字幕
And indeed, we've had strlen, we've had strcmp, we now have strcpy,

1496
01:11:22,490 --> 01:11:25,970
中文字幕
and if you read the documentation, this is deliberately reversed like this.

1497
01:11:25,970 --> 01:11:30,050
中文字幕
The destination is this variable, the source or the origin string

1498
01:11:30,050 --> 01:11:32,680
中文字幕
is this one, and it copies from one end to the other,

1499
01:11:32,680 --> 01:11:35,150
中文字幕
and then I don't need that for loop.

1500
01:11:35,150 --> 01:11:37,590
中文字幕
It just saves me a few lines of code.

1501
01:11:37,590 --> 01:11:38,240
中文字幕
All right.

1502
01:11:38,240 --> 01:11:41,750
中文字幕
So let's take off one other detail here.

1503
01:11:41,750 --> 01:11:46,520
中文字幕
Oh, and you'll notice, actually, let me make one fix, one fix here.

1504
01:11:46,520 --> 01:11:50,690
中文字幕
It turns out that what I'm doing here is a little lazy.

1505
01:11:50,690 --> 01:11:54,260
中文字幕
It turns out that malloc does have an opposite.

1506
01:11:54,260 --> 01:11:57,230
中文字幕
So anytime you allocate memory, technically

1507
01:11:57,230 --> 01:11:59,630
中文字幕
you should also be freeing that memory.

1508
01:11:59,630 --> 01:12:02,900
中文字幕
And so C allows you to ask the computer for as much memory as you want,

1509
01:12:02,900 --> 01:12:06,200
中文字幕
but if you never give it back, have you ever experienced on your own Mac or PC,

1510
01:12:06,200 --> 01:12:08,150
中文字幕
like after your computer's been running a while

1511
01:12:08,150 --> 01:12:10,700
中文字幕
or using some new or bloated program like a browser,

1512
01:12:10,700 --> 01:12:13,100
中文字幕
it gets slower and slower and slower?

1513
01:12:13,100 --> 01:12:16,610
中文字幕
And in the worse case it just freezes or hangs or something?

1514
01:12:16,610 --> 01:12:19,670
中文字幕
It is quite possible that that program simply-- was made by humans,

1515
01:12:19,670 --> 01:12:20,240
中文字幕
of course--

1516
01:12:20,240 --> 01:12:21,840
中文字幕
just has a memory leak.

1517
01:12:21,840 --> 01:12:25,400
中文字幕
So some human wrote one or more lines of code that uses malloc

1518
01:12:25,400 --> 01:12:28,520
中文字幕
or some equivalent in another language that just kept allocating memory

1519
01:12:28,520 --> 01:12:29,400
中文字幕
for the user's input.

1520
01:12:29,400 --> 01:12:31,310
中文字幕
You're visiting one web page, two web pages,

1521
01:12:31,310 --> 01:12:33,620
中文字幕
that requires memory whatever the program is.

1522
01:12:33,620 --> 01:12:37,490
中文字幕
And if that human never calls the opposite of allocate-- deallocate,

1523
01:12:37,490 --> 01:12:40,700
中文字幕
otherwise known as free, you're never giving the memory back

1524
01:12:40,700 --> 01:12:41,840
中文字幕
to the operating system.

1525
01:12:41,840 --> 01:12:45,120
中文字幕
So it gets slower and slower because it's running lower and lower and lower

1526
01:12:45,120 --> 01:12:47,420
中文字幕
on memory, and it might have to move some things around

1527
01:12:47,420 --> 01:12:50,390
中文字幕
to make room for things, that's what's called a memory leak.

1528
01:12:50,390 --> 01:12:54,170
中文字幕
And so indeed, in this program, I should actually improve this a little bit.

1529
01:12:54,170 --> 01:12:58,250
中文字幕
If I go back into this version here and line 18, recall,

1530
01:12:58,250 --> 01:13:01,010
中文字幕
I allocated this memory just to make my copy,

1531
01:13:01,010 --> 01:13:04,310
中文字幕
the very last thing I should actually do in this program

1532
01:13:04,310 --> 01:13:05,970
中文字幕
is this line here-- free.

1533
01:13:05,970 --> 01:13:08,810
中文字幕
You don't have to tell the computer how many bytes you want to free,

1534
01:13:08,810 --> 01:13:12,650
中文字幕
it will remember for you so long as you're just pass in the pointer--

1535
01:13:12,650 --> 01:13:16,790
中文字幕
the variable that's storing the address of the chunk of memory

1536
01:13:16,790 --> 01:13:18,890
中文字幕
that you allocated.

1537
01:13:18,890 --> 01:13:19,700
中文字幕
All right.

1538
01:13:19,700 --> 01:13:23,030
中文字幕
So let's now see why we've been using get_string,

1539
01:13:23,030 --> 01:13:25,430
中文字幕
since it's not just to kind of simplify the code,

1540
01:13:25,430 --> 01:13:28,640
中文字幕
it's also to defend against some very easy problems.

1541
01:13:28,640 --> 01:13:31,220
中文字幕
Here is a program called scanf0--

1542
01:13:31,220 --> 01:13:35,070
中文字幕
scanned formatted text, another arcane-sounding function,

1543
01:13:35,070 --> 01:13:36,630
中文字幕
but it's pretty straightforward.

1544
01:13:36,630 --> 01:13:39,950
中文字幕
This program simply gets in from the user using scanf.

1545
01:13:39,950 --> 01:13:42,410
中文字幕
Up until now for the past three weeks, you've used get_int.

1546
01:13:42,410 --> 01:13:45,050
中文字幕
So this is an alternative to get_int that you could

1547
01:13:45,050 --> 01:13:48,320
中文字幕
have started using a few weeks ago.

1548
01:13:48,320 --> 01:13:51,430
中文字幕
Give me an int called x, print out x colon whatever--

1549
01:13:51,430 --> 01:13:53,190
中文字幕
that's just the prompt to the user.

1550
01:13:53,190 --> 01:14:01,490
中文字幕
scanf %i, &x;, whatever that is, and then print out x's value using %i.

1551
01:14:01,490 --> 01:14:02,810
中文字幕
So what's going on here?

1552
01:14:02,810 --> 01:14:06,140
中文字幕
Now today we can actually start to wrap our minds around what get_int actually

1553
01:14:06,140 --> 01:14:06,630
中文字幕
does.

1554
01:14:06,630 --> 01:14:07,910
中文字幕
This is effectively get_int.

1555
01:14:07,910 --> 01:14:11,030
中文字幕
If you actually look at the source code for get_int, it's a little fancier.

1556
01:14:11,030 --> 01:14:13,990
中文字幕
But in essence, what get_int does is it declares a variable called x,

1557
01:14:13,990 --> 01:14:16,040
中文字幕
and it doesn't put anything there, because that's

1558
01:14:16,040 --> 01:14:17,630
中文字幕
supposed to come from you, the human.

1559
01:14:17,630 --> 01:14:20,900
中文字幕
It then prompts you for whatever string you pass to get_int,

1560
01:14:20,900 --> 01:14:22,370
中文字幕
so those are the first two lines.

1561
01:14:22,370 --> 01:14:24,570
中文字幕
And this is the only weird-looking one.

1562
01:14:24,570 --> 01:14:26,630
中文字幕
Scanf is like the opposite of printf.

1563
01:14:26,630 --> 01:14:31,920
中文字幕
You still use a formatted string-- %s, %i, %f or whatever,

1564
01:14:31,920 --> 01:14:35,750
中文字幕
but you're not going to output this, you're going to input this from

1565
01:14:35,750 --> 01:14:37,220
中文字幕
the human's keyboard.

1566
01:14:37,220 --> 01:14:41,780
中文字幕
And %x is the opposite of--

1567
01:14:41,780 --> 01:14:49,160
中文字幕
is the special symbol in C that says, go ahead and get me the address of x.

1568
01:14:49,160 --> 01:14:52,370
中文字幕
So don't pass in x, give me the address of x.

1569
01:14:52,370 --> 01:14:53,110
中文字幕
Now why is that?

1570
01:14:53,110 --> 01:14:56,390
中文字幕
We'll see, but this is the way where you can tell the computer,

1571
01:14:56,390 --> 01:14:59,510
中文字幕
I've made a variable for you called x, here is where it is.

1572
01:14:59,510 --> 01:15:03,840
中文字幕
It's a treasure map that leads you to x, go put a value here for me.

1573
01:15:03,840 --> 01:15:06,800
中文字幕
And so the end result is that we do, in fact, end up getting an int.

1574
01:15:06,800 --> 01:15:13,010
中文字幕
If I do make scanf0, and then ./scanf0, I'll type in 42, all right?

1575
01:15:13,010 --> 01:15:16,040
中文字幕
It's not an interesting program, it just spits back out what I got,

1576
01:15:16,040 --> 01:15:18,330
中文字幕
but that's literally all that get_int, of course,

1577
01:15:18,330 --> 01:15:20,270
中文字幕
is doing if you then print out the value.

1578
01:15:20,270 --> 01:15:24,230
中文字幕
So if I stipulate this is correct, this is how you get an int from the user,

1579
01:15:24,230 --> 01:15:27,660
中文字幕
but honestly, the reason we don't do this in week 1 of the course is like,

1580
01:15:27,660 --> 01:15:31,070
中文字幕
my God, we just took the fun out of even getting a simple number from the user

1581
01:15:31,070 --> 01:15:32,980
中文字幕
by using these lines of code and whoever knows

1582
01:15:32,980 --> 01:15:35,480
中文字幕
what this symbol is-- we don't want you to think about that,

1583
01:15:35,480 --> 01:15:36,800
中文字幕
we want you to just get an int.

1584
01:15:36,800 --> 01:15:39,230
中文字幕
But today those training wheels are off, but we're

1585
01:15:39,230 --> 01:15:41,990
中文字幕
going to run into a problem super fast.

1586
01:15:41,990 --> 01:15:44,540
中文字幕
Let's try the same thing with a string.

1587
01:15:44,540 --> 01:15:49,680
中文字幕
If I were to do this, you would think that the result is the same.

1588
01:15:49,680 --> 01:15:52,070
中文字幕
Or let's just do it as char*.

1589
01:15:52,070 --> 01:15:54,020
中文字幕
But there's going to be one tweak.

1590
01:15:54,020 --> 01:15:59,180
中文字幕
If I go ahead and give myself space for the address of a character,

1591
01:15:59,180 --> 01:16:01,970
中文字幕
I don't need to use the ampersand now, because scanf

1592
01:16:01,970 --> 01:16:04,880
中文字幕
does need to be told where the chunk of memory is,

1593
01:16:04,880 --> 01:16:08,630
中文字幕
but it's already an address, so I don't need the ampersand here.

1594
01:16:08,630 --> 01:16:11,960
中文字幕
Recall earlier, I declared int x, which was just an int.

1595
01:16:11,960 --> 01:16:14,500
中文字幕
%x gets the address of that int.

1596
01:16:14,500 --> 01:16:19,160
中文字幕
Here, I'm saying from the get-go, get me the address of a char.

1597
01:16:19,160 --> 01:16:22,070
中文字幕
I don't need the ampersand cause I already have the address of a char

1598
01:16:22,070 --> 01:16:24,650
中文字幕
by definition of that star symbol.

1599
01:16:24,650 --> 01:16:26,580
中文字幕
So what's going on here?

1600
01:16:26,580 --> 01:16:27,560
中文字幕
Let me see now.

1601
01:16:27,560 --> 01:16:30,420
中文字幕
If I run scanf1, what happens?

1602
01:16:30,420 --> 01:16:33,410
中文字幕
So make scanf1 and--

1603
01:16:33,410 --> 01:16:34,120
中文字幕
oh, let's see.

1604
01:16:34,120 --> 01:16:35,330
中文字幕
Here's a warning I'm getting.

1605
01:16:35,330 --> 01:16:37,370
中文字幕
Variable s is uninitialized when used here.

1606
01:16:37,370 --> 01:16:38,330
中文字幕
All right, that's fine.

1607
01:16:38,330 --> 01:16:41,210
中文字幕
It wants me to initialize it because this is a very common mistake.

1608
01:16:41,210 --> 01:16:43,160
中文字幕
Those of you who alluded to segmentation faults

1609
01:16:43,160 --> 01:16:46,040
中文字幕
earlier might have encountered something similar in spirit to this.

1610
01:16:46,040 --> 01:16:47,370
中文字幕
So that squelched that error.

1611
01:16:47,370 --> 01:16:49,330
中文字幕
Let me go ahead and run scanf1.

1612
01:16:49,330 --> 01:16:51,960
中文字幕
All right, here we go, TJ.

1613
01:16:51,960 --> 01:16:52,460
中文字幕
Hmm.

1614
01:16:52,460 --> 01:16:54,490
中文字幕
That is not your name, but OK.

1615
01:16:54,490 --> 01:16:57,000
中文字幕
It didn't crash at least, it's just a little weird.

1616
01:16:57,000 --> 01:16:58,280
中文字幕
David.

1617
01:16:58,280 --> 01:16:59,910
中文字幕
Null, OK, that's a little weird.

1618
01:16:59,910 --> 01:17:01,290
中文字幕
Let's go ahead and do this again.

1619
01:17:01,290 --> 01:17:03,740
中文字幕
Let's type in a really long name.

1620
01:17:06,280 --> 01:17:07,140
中文字幕
Enter.

1621
01:17:07,140 --> 01:17:09,060
中文字幕
Dammit, that didn't work.

1622
01:17:09,060 --> 01:17:11,250
中文字幕
So let's try an even longer name.

1623
01:17:16,350 --> 01:17:19,980
中文字幕
I'm hitting paste a lot.

1624
01:17:19,980 --> 01:17:21,790
中文字幕
OK-- dammit.

1625
01:17:21,790 --> 01:17:23,920
中文字幕
Too many times.

1626
01:17:23,920 --> 01:17:26,530
中文字幕
Command not found, that's definitely not a command.

1627
01:17:26,530 --> 01:17:27,310
中文字幕
Wow, OK.

1628
01:17:30,450 --> 01:17:32,000
中文字幕
Well that's interesting.

1629
01:17:32,000 --> 01:17:32,670
中文字幕
Oh, there it is.

1630
01:17:32,670 --> 01:17:33,610
中文字幕
Null, same thing.

1631
01:17:33,610 --> 01:17:36,260
中文字幕
OK, so what's actually going on?

1632
01:17:36,260 --> 01:17:38,370
中文字幕
Well null, which is all lowercase here, which

1633
01:17:38,370 --> 01:17:41,740
中文字幕
is this kind of an aesthetic thing, well it's not working.

1634
01:17:41,740 --> 01:17:42,450
中文字幕
It's not working.

1635
01:17:42,450 --> 01:17:44,010
中文字幕
Well what am I actually doing?

1636
01:17:44,010 --> 01:17:49,470
中文字幕
In that first line of code, when I say give me s to be a char*,

1637
01:17:49,470 --> 01:17:52,650
中文字幕
otherwise known as a string, all that's doing is allocating this.

1638
01:17:52,650 --> 01:17:54,750
中文字幕
And it's technically the size of a pointer.

1639
01:17:54,750 --> 01:17:57,330
中文字幕
A pointer, we never mentioned this before, but now we can.

1640
01:17:57,330 --> 01:18:02,910
中文字幕
Turns out it is 64 bits or 8 bytes.

1641
01:18:02,910 --> 01:18:07,770
中文字幕
8 bits is 1 bytes, so a pointer is by definition on many computers these

1642
01:18:07,770 --> 01:18:11,610
中文字幕
days-- most of your Macs, most of your PCs, the IDE, the Sandbox, the Lab--

1643
01:18:11,610 --> 01:18:12,460
中文字幕
is 64-bit.

1644
01:18:12,460 --> 01:18:16,260
中文字幕
So that just means there's 64 bits here, but we initialized it to null,

1645
01:18:16,260 --> 01:18:20,190
中文字幕
so that just means there's 64 0's here, dot-dot-dot.

1646
01:18:20,190 --> 01:18:24,090
中文字幕
But when I get a string using scanf, what

1647
01:18:24,090 --> 01:18:26,550
中文字幕
I'm telling the computer to do with this line of code here,

1648
01:18:26,550 --> 01:18:31,930
中文字幕
notice, is hey computer, go to that address and put a string there.

1649
01:18:31,930 --> 01:18:34,150
中文字幕
So what's actually happening?

1650
01:18:34,150 --> 01:18:37,680
中文字幕
It turns out that there's just not enough room to type in TJ.

1651
01:18:37,680 --> 01:18:38,720
中文字幕
There's not enough room--

1652
01:18:38,720 --> 01:18:41,430
中文字幕
that's a bit of a white lie, because we could fit you in 64 bits,

1653
01:18:41,430 --> 01:18:45,030
中文字幕
but there's not enough room to type in the long sentence or paragraph of text

1654
01:18:45,030 --> 01:18:46,140
中文字幕
I did, right?

1655
01:18:46,140 --> 01:18:47,340
中文字幕
What did we not do?

1656
01:18:47,340 --> 01:18:49,500
中文字幕
We didn't allocate any space over here.

1657
01:18:49,500 --> 01:18:51,930
中文字幕
All we allocated space for was the address.

1658
01:18:51,930 --> 01:18:55,770
中文字幕
And so every time I use scanf saying, get me a string and put it here,

1659
01:18:55,770 --> 01:18:57,220
中文字幕
there's nowhere to put it.

1660
01:18:57,220 --> 01:19:00,070
中文字幕
And so the value just very defensively says, no, like no,

1661
01:19:00,070 --> 01:19:03,030
中文字幕
cannot store this anywhere for you.

1662
01:19:03,030 --> 01:19:05,550
中文字幕
So I actually need to be a little smarter about this.

1663
01:19:05,550 --> 01:19:10,860
中文字幕
I actually need to get myself some space so that I can actually store something

1664
01:19:10,860 --> 01:19:11,750
中文字幕
in the right place.

1665
01:19:11,750 --> 01:19:12,670
中文字幕
Let's do that.

1666
01:19:12,670 --> 01:19:15,420
中文字幕
Let me go ahead and create a new program.

1667
01:19:15,420 --> 01:19:17,280
中文字幕
I'm going to go ahead and call this scanf2.

1668
01:19:21,370 --> 01:19:25,040
中文字幕
We need a little secret code to remind me of that.

1669
01:19:25,040 --> 01:19:27,180
中文字幕
Oh, wrong file name.

1670
01:19:27,180 --> 01:19:30,650
中文字幕
So I'm gone ahead and create a file called scanf2.

1671
01:19:30,650 --> 01:19:32,180
中文字幕
scanf2.c.

1672
01:19:32,180 --> 01:19:37,310
中文字幕
And I'm going to quickly recreate this stdio.h, int main void,

1673
01:19:37,310 --> 01:19:39,950
中文字幕
and then down here I'm going to go ahead and-- you know what?

1674
01:19:39,950 --> 01:19:44,270
中文字幕
Instead of a string s, which I know today to be a char* s,

1675
01:19:44,270 --> 01:19:45,540
中文字幕
what is this string really?

1676
01:19:45,540 --> 01:19:46,590
中文字幕
Well you said it earlier.

1677
01:19:46,590 --> 01:19:48,520
中文字幕
What is this string?

1678
01:19:48,520 --> 01:19:49,840
中文字幕
It's an array of characters.

1679
01:19:49,840 --> 01:19:51,210
中文字幕
Let me take you literally.

1680
01:19:51,210 --> 01:19:54,570
中文字幕
Just give me an array of let's say five characters.

1681
01:19:54,570 --> 01:19:58,980
中文字幕
The D-A-V-I-D, or one more, that's fine, just enough for my backslash 0.

1682
01:19:58,980 --> 01:20:01,330
中文字幕
Let me just create a string-- really low level,

1683
01:20:01,330 --> 01:20:03,670
中文字幕
but this time give myself the chunk of memory.

1684
01:20:03,670 --> 01:20:05,550
中文字幕
I don't want just the address of a character,

1685
01:20:05,550 --> 01:20:08,290
中文字幕
I want the actual characters themselves.

1686
01:20:08,290 --> 01:20:11,550
中文字幕
Let me go ahead and just prompt the human for their string with s,

1687
01:20:11,550 --> 01:20:12,510
中文字幕
just like before.

1688
01:20:12,510 --> 01:20:16,770
中文字幕
Then let me call scanf and get a string from the user using %s and then pass

1689
01:20:16,770 --> 01:20:17,400
中文字幕
in s.

1690
01:20:17,400 --> 01:20:18,720
中文字幕
And here's a little trick.

1691
01:20:18,720 --> 01:20:22,710
中文字幕
It turns out that because a string is really just an array,

1692
01:20:22,710 --> 01:20:25,620
中文字幕
but a string is also just a pointer, you can actually treat

1693
01:20:25,620 --> 01:20:28,440
中文字幕
an array as though it is a pointer--

1694
01:20:28,440 --> 01:20:29,310
中文字幕
an address.

1695
01:20:29,310 --> 01:20:33,900
中文字幕
And so even though this is a char* array, this is OK.

1696
01:20:33,900 --> 01:20:37,710
中文字幕
This is the equivalent in this context to being just the address of a string.

1697
01:20:37,710 --> 01:20:41,880
中文字幕
Because strings are arrays, arrays can be treated as pointers as of now.

1698
01:20:41,880 --> 01:20:44,880
中文字幕
And then let me go ahead and just print out whatever the human typed in.

1699
01:20:44,880 --> 01:20:46,470
中文字幕
S is actually this.

1700
01:20:46,470 --> 01:20:49,320
中文字幕
Pass in s;, save.

1701
01:20:49,320 --> 01:20:49,980
中文字幕
Yeah?

1702
01:20:49,980 --> 01:20:52,580
中文字幕
AUDIENCE: So [INAUDIBLE] char*?

1703
01:20:52,580 --> 01:20:55,130
中文字幕
At this point it would be redundant to do char*,

1704
01:20:55,130 --> 01:20:58,670
中文字幕
because I literally want for this story six characters.

1705
01:20:58,670 --> 01:21:01,740
中文字幕
I want space, rather, for six characters.

1706
01:21:01,740 --> 01:21:05,780
中文字幕
So this is kind of week 2 stuff now, there's no pointers involved.

1707
01:21:05,780 --> 01:21:08,810
中文字幕
But again, just showing the equivalence of these ideas for now.

1708
01:21:08,810 --> 01:21:12,560
中文字幕
So if I now go into this, and this is in my other directory at the moment,

1709
01:21:12,560 --> 01:21:19,760
中文字幕
make scanf2, Enter, ./scanf2, s is going to type in--

1710
01:21:19,760 --> 01:21:22,860
中文字幕
I'll type in my name, I know I can fit that, we're back in business.

1711
01:21:22,860 --> 01:21:26,030
中文字幕
Like now it's working because I didn't just create the address for a string,

1712
01:21:26,030 --> 01:21:27,480
中文字幕
I created the space for the string.

1713
01:21:27,480 --> 01:21:31,250
中文字幕
But let me get a little dangerous--

1714
01:21:31,250 --> 01:21:32,510
中文字幕
David Malan?

1715
01:21:32,510 --> 01:21:35,180
中文字幕
OK, that kind of worked out OK.

1716
01:21:35,180 --> 01:21:40,860
中文字幕
David Malan or some really long other name?

1717
01:21:40,860 --> 01:21:42,230
中文字幕
OK, that worked out too.

1718
01:21:42,230 --> 01:21:44,690
中文字幕
Let me go ahead and run it again.

1719
01:21:44,690 --> 01:21:48,070
中文字幕
Let me try that really long string again, see what happens.

1720
01:21:48,070 --> 01:21:49,910
中文字幕
I know this didn't work very well last time.

1721
01:21:49,910 --> 01:21:51,470
中文字幕
All right, done.

1722
01:21:51,470 --> 01:21:53,090
中文字幕
Ooh, OK.

1723
01:21:53,090 --> 01:21:57,470
中文字幕
So now I'm in the club of those of you who have had segmentation faults.

1724
01:21:57,470 --> 01:21:59,930
中文字幕
So let's understand what's going on here.

1725
01:21:59,930 --> 01:22:01,970
中文字幕
Segmentation fault a moment ago I claimed

1726
01:22:01,970 --> 01:22:05,420
中文字幕
was touching a segment, a chunk of memory that's not your own.

1727
01:22:05,420 --> 01:22:06,410
中文字幕
So just happened?

1728
01:22:06,410 --> 01:22:09,230
中文字幕
Well with this simple program, I told the computer, hey computer,

1729
01:22:09,230 --> 01:22:13,670
中文字幕
give me room for six characters, give me six bytes.

1730
01:22:13,670 --> 01:22:18,170
中文字幕
With the scanf line, I'm telling the computer, put the following user

1731
01:22:18,170 --> 01:22:22,280
中文字幕
input at that location, in that array of characters.

1732
01:22:22,280 --> 01:22:24,830
中文字幕
D-A-V-I-D backslash 0 fit.

1733
01:22:24,830 --> 01:22:27,890
中文字幕
David Malan didn't really, but it didn't seem to be a huge deal.

1734
01:22:27,890 --> 01:22:33,000
中文字幕
David Malan or some really long other name, also didn't crash the computer.

1735
01:22:33,000 --> 01:22:36,360
中文字幕
But that's because unbeknownst to us, usually when you ask for six bytes,

1736
01:22:36,360 --> 01:22:38,990
中文字幕
the computer is kind of sort of-- it's giving you a few extras.

1737
01:22:38,990 --> 01:22:41,480
中文字幕
It's not safe to use them, but it gives you enough

1738
01:22:41,480 --> 01:22:44,870
中文字幕
that you're not going to necessarily see a problem like a segmentation fault.

1739
01:22:44,870 --> 01:22:47,310
中文字幕
But it only allocates a few extra bytes typically,

1740
01:22:47,310 --> 01:22:51,010
中文字幕
so if you really keep pasting in long, long, long, long lines of text,

1741
01:22:51,010 --> 01:22:53,060
中文字幕
eventually you're going exceed not only those six

1742
01:22:53,060 --> 01:22:55,630
中文字幕
bytes, but well past the special--

1743
01:22:55,630 --> 01:22:58,550
中文字幕
the secret bytes that you got back that you shouldn't be using anyway,

1744
01:22:58,550 --> 01:23:00,670
中文字幕
and that point the computer just gives up and says,

1745
01:23:00,670 --> 01:23:03,080
中文字幕
you are touching memory you shouldn't, a.k.a.

1746
01:23:03,080 --> 01:23:04,040
中文字幕
segmentation fault.

1747
01:23:04,040 --> 01:23:06,510
中文字幕
if the computer gives you

1748
01:23:06,510 --> 01:23:10,460
中文字幕
a few extra bytes, then why isn't it printing any of the other stuff?

1749
01:23:10,460 --> 01:23:14,150
中文字幕
After you said [INAUDIBLE] it just printed David.

1750
01:23:14,150 --> 01:23:15,570
中文字幕
Really good question.

1751
01:23:15,570 --> 01:23:18,230
中文字幕
So even though I'm getting these sort of extra bytes,

1752
01:23:18,230 --> 01:23:20,720
中文字幕
why am I not seeing them after D-A-V-I-D?

1753
01:23:20,720 --> 01:23:21,920
中文字幕
I'm probably getting lucky.

1754
01:23:21,920 --> 01:23:24,560
中文字幕
Long story short, when you first run a program,

1755
01:23:24,560 --> 01:23:28,370
中文字幕
much of the memory that your program has access to is by default initialized

1756
01:23:28,370 --> 01:23:29,710
中文字幕
to 0's.

1757
01:23:29,710 --> 01:23:33,590
中文字幕
0 is the same thing as backslash 0, and so I'm getting lucky.

1758
01:23:33,590 --> 01:23:37,250
中文字幕
When I had D-A-V-I-D and then excess space in that array,

1759
01:23:37,250 --> 01:23:39,830
中文字幕
a lot of them are initialized as 0's already,

1760
01:23:39,830 --> 01:23:43,150
中文字幕
and the string is getting secretly terminated for me.

1761
01:23:43,150 --> 01:23:46,880
中文字幕
Or the better answer is, it's undefined behavior.

1762
01:23:46,880 --> 01:23:49,160
中文字幕
Like you should not touch memory that is not your own.

1763
01:23:49,160 --> 01:23:52,820
中文字幕
What happens after that is your risk alone.

1764
01:23:52,820 --> 01:23:55,490
中文字幕
But that's a conjecture as to why that's happening.

1765
01:23:55,490 --> 01:23:58,460
中文字幕
All right, so what is the fundamental feature than get_int

1766
01:23:58,460 --> 01:23:59,750
中文字幕
is providing for us?

1767
01:23:59,750 --> 01:24:02,480
中文字幕
All of this time get_int has actually been dealing

1768
01:24:02,480 --> 01:24:04,410
中文字幕
with all of this headache for us.

1769
01:24:04,410 --> 01:24:07,250
中文字幕
I mean honestly, even I'm getting bored like thinking about, talking

1770
01:24:07,250 --> 01:24:09,530
中文字幕
about how you just get a damn string from the user,

1771
01:24:09,530 --> 01:24:12,190
中文字幕
because you need to figure out, well how many bytes do you need?

1772
01:24:12,190 --> 01:24:15,070
中文字幕
And what if the human types in one more bite than you were expecting?

1773
01:24:15,070 --> 01:24:17,300
中文字幕
Then you need to do a switcheroo and get more memory.

1774
01:24:17,300 --> 01:24:20,050
中文字幕
get_string is doing all of this headache for us.

1775
01:24:20,050 --> 01:24:22,100
中文字幕
And that's not to say you need to use it forever,

1776
01:24:22,100 --> 01:24:23,930
中文字幕
there are indeed training wheels, but that's

1777
01:24:23,930 --> 01:24:27,560
中文字幕
just because when you're using C or a lot of programming languages,

1778
01:24:27,560 --> 01:24:29,610
中文字幕
the computer will only do what you tell it to do.

1779
01:24:29,610 --> 01:24:31,920
中文字幕
And it turns out that even asking the user for input,

1780
01:24:31,920 --> 01:24:34,010
中文字幕
if you don't know how many characters he or she is

1781
01:24:34,010 --> 01:24:37,140
中文字幕
going to type in from the get-go, you have to deal with it.

1782
01:24:37,140 --> 01:24:40,310
中文字幕
And so underneath the hood-- and you're welcome to take a look at the source

1783
01:24:40,310 --> 01:24:44,090
中文字幕
code for CS50's library, which I'll post on the home page later today,

1784
01:24:44,090 --> 01:24:48,050
中文字幕
it turns out that with the way we're doing get_string is taking baby steps.

1785
01:24:48,050 --> 01:24:50,780
中文字幕
We literally like get one character at a time

1786
01:24:50,780 --> 01:24:54,360
中文字幕
from the user, kind of building the road as we go.

1787
01:24:54,360 --> 01:24:56,660
中文字幕
And if we don't have enough space, we ask the computer,

1788
01:24:56,660 --> 01:24:58,650
中文字幕
give me some more bytes so I can get more bytes,

1789
01:24:58,650 --> 01:25:01,130
中文字幕
and we just get one character at a time so

1790
01:25:01,130 --> 01:25:04,520
中文字幕
that we can handle the user maliciously or accidentally typing in way

1791
01:25:04,520 --> 01:25:08,460
中文字幕
more input than we actually expect.

1792
01:25:08,460 --> 01:25:10,640
中文字幕
So let's contextualize all of this then.

1793
01:25:10,640 --> 01:25:12,950
中文字幕
Recall that we've been drawing these pictures the past couple of weeks.

1794
01:25:12,950 --> 01:25:15,560
中文字幕
Let's just make this super clear as to what's been going on.

1795
01:25:15,560 --> 01:25:17,870
中文字幕
This is a memory module in a computer.

1796
01:25:17,870 --> 01:25:20,600
中文字幕
It's just a green board, it's way blown out of scale here,

1797
01:25:20,600 --> 01:25:24,620
中文字幕
it's easily like yea big inside of your Mac or PC laptop or desktop,

1798
01:25:24,620 --> 01:25:25,880
中文字幕
though can vary in size.

1799
01:25:25,880 --> 01:25:28,500
中文字幕
One of these black chips is the actual memory or the bytes

1800
01:25:28,500 --> 01:25:29,750
中文字幕
to which we've been referring.

1801
01:25:29,750 --> 01:25:32,300
中文字幕
And if we zoom in on that, recall that I proposed last week

1802
01:25:32,300 --> 01:25:35,090
中文字幕
that you can just think about this as like a grid, an array.

1803
01:25:35,090 --> 01:25:38,180
中文字幕
And it doesn't have to be rectangular, this is just an artist's rendition,

1804
01:25:38,180 --> 01:25:41,120
中文字幕
but each of those squares represents, we claimed, a byte.

1805
01:25:41,120 --> 01:25:44,880
中文字幕
And each of those bytes can be addressed in some way with a number.

1806
01:25:44,880 --> 01:25:49,250
中文字幕
And that number is just its location, otherwise known as an address.

1807
01:25:49,250 --> 01:25:52,590
中文字幕
We can actually see this, it turns out, as follows.

1808
01:25:52,590 --> 01:25:54,670
中文字幕
Let me go ahead and open up this example here.

1809
01:25:54,670 --> 01:25:57,260
中文字幕
Or actually, you know, let's just write this one from scratch.

1810
01:25:57,260 --> 01:26:01,930
中文字幕
Let me write a program called addresses.c.

1811
01:26:01,930 --> 01:26:09,230
中文字幕
And that's going to use our old friends, the CS50 library and stdio.h and int

1812
01:26:09,230 --> 01:26:11,090
中文字幕
main void.

1813
01:26:11,090 --> 01:26:13,580
中文字幕
And let me go ahead and just do this.

1814
01:26:13,580 --> 01:26:15,300
中文字幕
I'm going to go ahead and get a string--

1815
01:26:15,300 --> 01:26:15,890
中文字幕
you know what?

1816
01:26:15,890 --> 01:26:21,420
中文字幕
No more string. char* from the user, get_string, ask the user for s.

1817
01:26:21,420 --> 01:26:23,050
中文字幕
And we get another string, a.k.a.

1818
01:26:23,050 --> 01:26:26,630
中文字幕
char*, get_string, call it t from the user.

1819
01:26:26,630 --> 01:26:31,580
中文字幕
And then, I want to print out not the strings, which I used to do like this,

1820
01:26:31,580 --> 01:26:32,550
中文字幕
printing out s.

1821
01:26:32,550 --> 01:26:37,360
中文字幕
I want to print out the pointer that s really is, that is the address.

1822
01:26:37,360 --> 01:26:42,380
中文字幕
Turns out %p for pointer will print out not the string at that memory location,

1823
01:26:42,380 --> 01:26:45,620
中文字幕
it will print the actual memory location for you of s.

1824
01:26:45,620 --> 01:26:50,480
中文字幕
And I can do the same thing here, %p, backslash 0, paste in t.

1825
01:26:50,480 --> 01:26:52,940
中文字幕
And just so I know which is which, let me just prefix it

1826
01:26:52,940 --> 01:26:55,460
中文字幕
with some text-- s colon and t colon.

1827
01:26:55,460 --> 01:26:58,840
中文字幕
Let me go ahead now down here and do make addresses.

1828
01:26:58,840 --> 01:27:02,390
中文字幕
Oh, I messed up, missed a semi-colon.

1829
01:27:02,390 --> 01:27:03,500
中文字幕
Let me do this again.

1830
01:27:03,500 --> 01:27:07,940
中文字幕
make addresses.

1831
01:27:07,940 --> 01:27:09,830
中文字幕
And get rid of this.

1832
01:27:09,830 --> 01:27:14,390
中文字幕
That compiled OK, ./addresses, and here we go.

1833
01:27:14,390 --> 01:27:18,210
中文字幕
Let's type in-- let's do Brian and Veronica like before.

1834
01:27:18,210 --> 01:27:18,970
中文字幕
Enter.

1835
01:27:18,970 --> 01:27:23,290
中文字幕
And this is a little funky, but it turns out the IDE in your Macs

1836
01:27:23,290 --> 01:27:25,430
中文字幕
and your PCs have a lot of memory.

1837
01:27:25,430 --> 01:27:26,600
中文字幕
So this is the address.

1838
01:27:26,600 --> 01:27:30,070
中文字幕
It's not quite as small as 100, it's not quite as small as 900.

1839
01:27:30,070 --> 01:27:31,750
中文字幕
It's actually kind of big.

1840
01:27:31,750 --> 01:27:36,240
中文字幕
It's 2331010 with this weird 0x.

1841
01:27:36,240 --> 01:27:38,370
中文字幕
Well it turns out, this is just a human convention.

1842
01:27:38,370 --> 01:27:40,510
中文字幕
In week 0 we talked about decimal and all of us

1843
01:27:40,510 --> 01:27:43,030
中文字幕
grew up with decimal, 10 digits from 0 to 9.

1844
01:27:43,030 --> 01:27:46,060
中文字幕
Talked a little bit about binary 0's and 1's.

1845
01:27:46,060 --> 01:27:48,700
中文字幕
Turns out there's an infinite number of base systems--

1846
01:27:48,700 --> 01:27:53,350
中文字幕
decimal/dec, binary/bi are just two of those infinite number of possibilities.

1847
01:27:53,350 --> 01:27:57,370
中文字幕
Turns out there's another one that's super common called hexadecimal.

1848
01:27:57,370 --> 01:27:59,890
中文字幕
Hexa meaning 16 in this case.

1849
01:27:59,890 --> 01:28:03,940
中文字幕
So base-16 actually has 16 letters in its alphabet.

1850
01:28:03,940 --> 01:28:11,560
中文字幕
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f.

1851
01:28:11,560 --> 01:28:15,990
中文字幕
So it turns out that base systems that need to count higher than 10 characters

1852
01:28:15,990 --> 01:28:18,430
中文字幕
just start using letters of the alphabet by convention.

1853
01:28:18,430 --> 01:28:19,840
中文字幕
Humans just decided this.

1854
01:28:19,840 --> 01:28:22,620
中文字幕
So we're getting just numbers in this case,

1855
01:28:22,620 --> 01:28:24,640
中文字幕
but if these addresses were even bigger, we

1856
01:28:24,640 --> 01:28:30,430
中文字幕
might actually see some alphabetical letters between a and f there.

1857
01:28:30,430 --> 01:28:32,350
中文字幕
And frankly I don't know what address this is,

1858
01:28:32,350 --> 01:28:34,300
中文字幕
but Google's usually pretty good at this stuff,

1859
01:28:34,300 --> 01:28:39,000
中文字幕
so let me actually open up another browser window.

1860
01:28:39,000 --> 01:28:39,300
中文字幕
So Google is your friend when it comes to this stuff, so let me actually open up another browser window.

1861
01:28:39,300 --> 01:28:41,340
中文字幕
So Google is your friend when it comes to this stuff,

1862
01:28:41,340 --> 01:28:42,570
中文字幕
or any number of calculators.

1863
01:28:42,570 --> 01:28:47,000
中文字幕
0x2331010 in decimal please.

1864
01:28:47,000 --> 01:28:48,300
中文字幕
And Google has translated that.

1865
01:28:48,300 --> 01:28:51,020
中文字幕
So Brian, I-- kind of under a bit earlier.

1866
01:28:51,020 --> 01:28:54,240
中文字幕
He is not at address location 0, he's actually

1867
01:28:54,240 --> 01:28:58,890
中文字幕
in the 36 millionth byte inside of my computer

1868
01:28:58,890 --> 01:29:02,760
中文字幕
right now, location 36,900,880.

1869
01:29:02,760 --> 01:29:05,100
中文字幕
So a little higher address than 100.

1870
01:29:05,100 --> 01:29:09,090
中文字幕
And then Veronica, if you really want to get into the weeds here,

1871
01:29:09,090 --> 01:29:12,400
中文字幕
we can say "in decimal," let Google translate that for us.

1872
01:29:12,400 --> 01:29:16,140
中文字幕
She's at location 36,900,944.

1873
01:29:16,140 --> 01:29:16,740
中文字幕
Why?

1874
01:29:16,740 --> 01:29:17,430
中文字幕
Who cares?

1875
01:29:17,430 --> 01:29:22,200
中文字幕
The computer is managing all of this for us, but when get_string used malloc,

1876
01:29:22,200 --> 01:29:26,160
中文字幕
these are literally the numbers that were being returned saying,

1877
01:29:26,160 --> 01:29:28,980
中文字幕
you may use this chunk of memory.

1878
01:29:28,980 --> 01:29:30,980
中文字幕
And why did humans use hexadecimal?

1879
01:29:30,980 --> 01:29:39,030
中文字幕
Like it's just slightly more compact to say 0x2331050, then 36900944--

1880
01:29:39,030 --> 01:29:41,640
中文字幕
like you just save a few digits, so it's just conventional.

1881
01:29:41,640 --> 01:29:43,090
中文字幕
That's all, there's no magic there.

1882
01:29:43,090 --> 01:29:44,580
中文字幕
But, recall earlier.

1883
01:29:44,580 --> 01:29:47,400
中文字幕
Do you recall that when I had the debugger open earlier,

1884
01:29:47,400 --> 01:29:51,820
中文字幕
you saw next to my name variable a value that was cryptically 0x0?

1885
01:29:51,820 --> 01:29:53,910
中文字幕
Then there was another value that I don't recall--

1886
01:29:53,910 --> 01:29:55,320
中文字幕
0x-something?

1887
01:29:55,320 --> 01:30:00,270
中文字幕
That was just the numeric address of my name in hexadecimal.

1888
01:30:00,270 --> 01:30:06,170
中文字幕
And 0x0 is just the technical address being used by null.

1889
01:30:06,170 --> 01:30:06,950
中文字幕
Yeah?

1890
01:30:06,950 --> 01:30:12,710
中文字幕
AUDIENCE: You said the address printed out was [INAUDIBLE] x of the variable s

1891
01:30:12,710 --> 01:30:13,210
中文字幕
and--

1892
01:30:13,210 --> 01:30:13,960
中文字幕
Sorry, could you say that again?

1893
01:30:13,960 --> 01:30:17,530
中文字幕
AUDIENCE: You said the address printed out on the screen was an x,

1894
01:30:17,530 --> 01:30:20,150
中文字幕
but x is [INAUDIBLE]

1895
01:30:20,150 --> 01:30:21,780
中文字幕
Ah, I should've clarified.

1896
01:30:21,780 --> 01:30:24,990
中文字幕
0x, humans years ago decided anytime you see anything

1897
01:30:24,990 --> 01:30:29,040
中文字幕
with 0x, that means whatever comes next is hexadecimal.

1898
01:30:29,040 --> 01:30:30,250
中文字幕
Just the convention.

1899
01:30:30,250 --> 01:30:35,010
中文字幕
It's also common too if it starts with a 0, it's an octal, which is base-8.

1900
01:30:35,010 --> 01:30:37,460
中文字幕
If you see a lowercase b at the end, it means binary.

1901
01:30:37,460 --> 01:30:39,210
中文字幕
So humans have just come up with symbology

1902
01:30:39,210 --> 01:30:41,850
中文字幕
as to kind of communicate this to readers, that's all.

1903
01:30:41,850 --> 01:30:42,930
中文字幕
Not part of the value.

1904
01:30:42,930 --> 01:30:45,840
中文字幕
So turns out that we can actually do this math ourselves.

1905
01:30:45,840 --> 01:30:47,760
中文字幕
And we won't really get into the weeds of this

1906
01:30:47,760 --> 01:30:50,010
中文字幕
because it's not a particularly useful life

1907
01:30:50,010 --> 01:30:52,310
中文字幕
skill, to be able to convert to various base systems,

1908
01:30:52,310 --> 01:30:54,480
中文字幕
but let's just do one example so that we've seen it.

1909
01:30:54,480 --> 01:30:56,070
中文字幕
Just to make clear that there's no magic here,

1910
01:30:56,070 --> 01:30:59,060
中文字幕
it's just a different way of thinking about numbers versus grade school.

1911
01:30:59,060 --> 01:31:01,470
中文字幕
So if back in the day we had three decimal numbers--

1912
01:31:01,470 --> 01:31:06,750
中文字幕
255, 216, and then another 255, if we rewound to week 0,

1913
01:31:06,750 --> 01:31:09,310
中文字幕
we could go through the math of converting that to binary.

1914
01:31:09,310 --> 01:31:12,480
中文字幕
And even if it might take you a little while, this is the binary equivalent.

1915
01:31:12,480 --> 01:31:15,590
中文字幕
And frankly, the first and last are kind of easy.

1916
01:31:15,590 --> 01:31:19,350
中文字幕
255 is kind of a special value because with 8 bits, all of which

1917
01:31:19,350 --> 01:31:21,690
中文字幕
are 1, that's what gives you 255.

1918
01:31:21,690 --> 01:31:23,500
中文字幕
So the only hard one is actually this.

1919
01:31:23,500 --> 01:31:25,410
中文字幕
But who cares about the math today.

1920
01:31:25,410 --> 01:31:28,350
中文字幕
We know from weeks ago that we can do this if we really tried.

1921
01:31:28,350 --> 01:31:35,760
中文字幕
But notice that bytes are eight bits, and of course, eight is a pair of four,

1922
01:31:35,760 --> 01:31:36,720
中文字幕
if you will.

1923
01:31:36,720 --> 01:31:40,800
中文字幕
Well what's really nice about hexadecimal is that it starts at 0

1924
01:31:40,800 --> 01:31:41,560
中文字幕
and ends at f.

1925
01:31:41,560 --> 01:31:46,100
中文字幕
And that's 0, 1, 2, 3, 4, 5, 6, 7, 8, 9--

1926
01:31:46,100 --> 01:31:47,560
中文字幕
wait-- yes, that's 10.

1927
01:31:47,560 --> 01:31:48,060
中文字幕
OK.

1928
01:31:48,060 --> 01:31:51,240
中文字幕
And then a, b, c, d, e, f.

1929
01:31:51,240 --> 01:31:54,840
中文字幕
I just held up 16 fingers in total, hence, hexadecimal.

1930
01:31:54,840 --> 01:32:00,630
中文字幕
What's nice about base-16 is that how many bits do I need to count from 0 up

1931
01:32:00,630 --> 01:32:02,010
中文字幕
to--

1932
01:32:02,010 --> 01:32:03,120
中文字幕
one, two, three, four--

1933
01:32:03,120 --> 01:32:05,400
中文字幕
15?

1934
01:32:05,400 --> 01:32:06,510
中文字幕
Just 4, right?

1935
01:32:06,510 --> 01:32:09,510
中文字幕
So if I have all 0 bits, that's 0.

1936
01:32:09,510 --> 01:32:13,010
中文字幕
And if I have 4 1-bits, that's--

1937
01:32:13,010 --> 01:32:13,560
中文字幕
let's see.

1938
01:32:13,560 --> 01:32:18,940
中文字幕
This is an 8 plus 4 plus 2 plus 1 gives me 15.

1939
01:32:18,940 --> 01:32:22,830
中文字幕
So long story short, hexadecimal's super convenient because 0 through f

1940
01:32:22,830 --> 01:32:25,230
中文字幕
maps wonderfully cleanly to 4 bits.

1941
01:32:25,230 --> 01:32:28,110
中文字幕
So it's just a nice way of thinking about the world not in units of 8

1942
01:32:28,110 --> 01:32:29,670
中文字幕
but in 4 instead.

1943
01:32:29,670 --> 01:32:31,800
中文字幕
So all I did here was I took my values and I just

1944
01:32:31,800 --> 01:32:33,720
中文字幕
added a little bit of whitespace to make clear

1945
01:32:33,720 --> 01:32:35,970
中文字幕
that 8 bits is like a pair of 4 bits.

1946
01:32:35,970 --> 01:32:40,760
中文字幕
It turns out now that 1 1 1 1 is f for the reasons I enumerated earlier.

1947
01:32:40,760 --> 01:32:44,700
中文字幕
All 1's is f, otherwise known as 15.

1948
01:32:44,700 --> 01:32:47,100
中文字幕
All 1's is again f, otherwise known as 15.

1949
01:32:47,100 --> 01:32:55,470
中文字幕
If we did the math, 1 1 0 1 is d, 1 0 0 0 is 8, and then all 1's is f and f.

1950
01:32:55,470 --> 01:32:58,710
中文字幕
So long story short, there is a way to convert from decimal

1951
01:32:58,710 --> 01:33:01,390
中文字幕
to binary, to hexadecimal, to any number of other base systems.

1952
01:33:01,390 --> 01:33:03,600
中文字幕
It all just boils down to what digits you care about.

1953
01:33:03,600 --> 01:33:05,640
中文字幕
And the way you write this, to your question earlier,

1954
01:33:05,640 --> 01:33:06,720
中文字幕
is by human convention.

1955
01:33:06,720 --> 01:33:12,510
中文字幕
Not just FFDAFF, but 0xFF0xD80xFF just because.

1956
01:33:12,510 --> 01:33:14,430
中文字幕
Then it's clear to the user what it is.

1957
01:33:14,430 --> 01:33:16,740
中文字幕
So a little levity now.

1958
01:33:16,740 --> 01:33:19,260
中文字幕
I'm sorry to do this to you, but now you will all hopefully

1959
01:33:19,260 --> 01:33:21,120
中文字幕
understand this famous comic.

1960
01:33:26,560 --> 01:33:29,610
中文字幕
OK, welcome to that club of people who understand things like this.

1961
01:33:29,610 --> 01:33:34,830
中文字幕
So let's now stumble upon just one last problem,

1962
01:33:34,830 --> 01:33:36,920
中文字幕
and we'll take it home by putting into the context

1963
01:33:36,920 --> 01:33:41,180
中文字幕
a very sexy field of forensics where all of these building blocks

1964
01:33:41,180 --> 01:33:42,190
中文字幕
will come into play.

1965
01:33:42,190 --> 01:33:43,740
中文字幕
But first let's start with a problem.

1966
01:33:43,740 --> 01:33:47,300
中文字幕
Suppose I want to implement a function here called swap whose purpose in life

1967
01:33:47,300 --> 01:33:49,160
中文字幕
is just to swap two values, a and b.

1968
01:33:49,160 --> 01:33:50,660
中文字幕
I just want to do a switcheroo.

1969
01:33:50,660 --> 01:33:54,800
中文字幕
Let's first do this with a sort of mid-lecture snack for at least

1970
01:33:54,800 --> 01:33:55,400
中文字幕
one person.

1971
01:33:55,400 --> 01:33:56,880
中文字幕
Would anyone be up for--

1972
01:33:56,880 --> 01:33:57,680
中文字幕
OK, that was fast.

1973
01:33:57,680 --> 01:34:00,080
中文字幕
Volunteering, come on up.

1974
01:34:00,080 --> 01:34:01,160
中文字幕
What's your name?

1975
01:34:01,160 --> 01:34:02,580
中文字幕
Kelly, all right.

1976
01:34:02,580 --> 01:34:04,210
中文字幕
Thank you for volunteering so suddenly.

1977
01:34:07,880 --> 01:34:09,720
中文字幕
Kelly, David, nice to meet you.

1978
01:34:09,720 --> 01:34:11,900
中文字幕
OK, so very simple task at hand.

1979
01:34:11,900 --> 01:34:16,080
中文字幕
I have here two empty cups, and we have some orange juice.

1980
01:34:19,480 --> 01:34:22,400
中文字幕
OK, put this in here.

1981
01:34:22,400 --> 01:34:26,890
中文字幕
And we've got some milk over here.

1982
01:34:26,890 --> 01:34:29,870
中文字幕
That should stand out, very different colors.

1983
01:34:29,870 --> 01:34:34,830
中文字幕
OK, I would just like you, Kelly, if you could, swap those two values.

1984
01:34:34,830 --> 01:34:37,000
中文字幕
Orange goes into milk, milk goes into orange please.

1985
01:34:42,450 --> 01:34:44,390
中文字幕
That is cheating, OK?

1986
01:34:44,390 --> 01:34:45,840
中文字幕
No, I mean literally the cups.

1987
01:34:45,840 --> 01:34:47,430
中文字幕
I put them in the wrong cup, I prefer my milk

1988
01:34:47,430 --> 01:34:50,130
中文字幕
in the other cup and my orange juice in the other cup, I'm sorry.

1989
01:34:53,190 --> 01:34:54,640
中文字幕
AUDIENCE: Pour it back in.

1990
01:34:54,640 --> 01:34:56,730
中文字幕
No, that is not available to you, OK?

1991
01:34:56,730 --> 01:34:57,860
中文字幕
[LAUGHTER]

1992
01:34:57,860 --> 01:34:59,280
中文字幕
OK, so you're struggling.

1993
01:34:59,280 --> 01:35:00,240
中文字幕
Why are you struggling?

1994
01:35:00,240 --> 01:35:01,830
中文字幕
KELLY: Because I'm going to mix them.

1995
01:35:01,830 --> 01:35:03,080
中文字幕
And then it won't be the same.

1996
01:35:03,080 --> 01:35:03,870
中文字幕
Right.

1997
01:35:03,870 --> 01:35:06,570
中文字幕
So I mean obviously, this is kind of a losing proposition.

1998
01:35:06,570 --> 01:35:07,320
中文字幕
You can't really do this.

1999
01:35:07,320 --> 01:35:09,300
中文字幕
What would make this easier for you besides putting them back

2000
01:35:09,300 --> 01:35:10,110
中文字幕
in the bottles?

2001
01:35:10,110 --> 01:35:10,870
中文字幕
KELLY: Having another container.

2002
01:35:10,870 --> 01:35:11,620
中文字幕
Yeah.

2003
01:35:11,620 --> 01:35:14,490
中文字幕
So you need like a temporary storage space for this.

2004
01:35:14,490 --> 01:35:15,240
中文字幕
You know, let me--

2005
01:35:15,240 --> 01:35:18,560
中文字幕
Tara, can we get some more cups over here?

2006
01:35:18,560 --> 01:35:20,700
中文字幕
Ah, this will make it easier.

2007
01:35:20,700 --> 01:35:22,760
中文字幕
OK, so if I get you some temporary space--

2008
01:35:22,760 --> 01:35:24,970
中文字幕
here you go-- could you solve the problem now please?

2009
01:35:28,330 --> 01:35:30,370
中文字幕
Ah, very nice.

2010
01:35:30,370 --> 01:35:35,150
中文字幕
A little contamination, but that's OK.

2011
01:35:35,150 --> 01:35:37,270
中文字幕
But I need that temporary cup back for Tara.

2012
01:35:37,270 --> 01:35:38,830
中文字幕
Yeah, OK.

2013
01:35:38,830 --> 01:35:39,790
中文字幕
Thank you.

2014
01:35:39,790 --> 01:35:42,250
中文字幕
All right, a round of applause if we could for Kelly here.

2015
01:35:42,250 --> 01:35:44,090
中文字幕
[APPLAUSE]

2016
01:35:44,090 --> 01:35:44,890
中文字幕
Well here we go.

2017
01:35:44,890 --> 01:35:47,230
中文字幕
I'm guessing you don't want warm milk, but orange juice?

2018
01:35:47,230 --> 01:35:47,720
中文字幕
OK.

2019
01:35:47,720 --> 01:35:48,490
中文字幕
Thank you so much.

2020
01:35:48,490 --> 01:35:50,350
中文字幕
All right, so what's the point here?

2021
01:35:50,350 --> 01:35:51,260
中文字幕
This is pretty easy.

2022
01:35:51,260 --> 01:35:53,350
中文字幕
Like once you have some temporary storage

2023
01:35:53,350 --> 01:35:57,140
中文字幕
space-- a variable, if you will, like it's no problem to swap two values.

2024
01:35:57,140 --> 01:36:00,080
中文字幕
So let me go ahead and do that as follows.

2025
01:36:00,080 --> 01:36:02,740
中文字幕
I'm going to go ahead and just implement this swap function

2026
01:36:02,740 --> 01:36:05,760
中文字幕
and see exactly as Kelly ultimately just implemented it.

2027
01:36:05,760 --> 01:36:09,430
中文字幕
If the goal is to swap a and b, I can't just do a complete switcheroo,

2028
01:36:09,430 --> 01:36:10,090
中文字幕
it seems.

2029
01:36:10,090 --> 01:36:13,600
中文字幕
I need to put one of those values, like the milk, in another container,

2030
01:36:13,600 --> 01:36:15,100
中文字幕
and then swap and then swap.

2031
01:36:15,100 --> 01:36:17,170
中文字幕
So it takes three steps, not just one.

2032
01:36:17,170 --> 01:36:19,810
中文字幕
All right, so I could call this extra variable or cup

2033
01:36:19,810 --> 01:36:22,270
中文字幕
that Tara gave us anything we want-- tmp.

2034
01:36:22,270 --> 01:36:25,210
中文字幕
So I'm just going to put a in tmp.

2035
01:36:25,210 --> 01:36:28,540
中文字幕
Then I'm going to put b in a, because a is now empty.

2036
01:36:28,540 --> 01:36:31,050
中文字幕
Then I'm going to put tmp in b, and then I don't really

2037
01:36:31,050 --> 01:36:33,760
中文字幕
care what happens to tmp-- indeed, it's just still sitting there,

2038
01:36:33,760 --> 01:36:35,690
中文字幕
but the job is now done.

2039
01:36:35,690 --> 01:36:39,610
中文字幕
So let's go ahead and see this program in action, because obviously this

2040
01:36:39,610 --> 01:36:40,990
中文字幕
should be pretty straightforward.

2041
01:36:40,990 --> 01:36:44,260
中文字幕
So let me go ahead and open up this program

2042
01:36:44,260 --> 01:36:47,920
中文字幕
in the context of a main function so we can actually run it.

2043
01:36:47,920 --> 01:36:51,030
中文字幕
In this code here, I'm going to demonstrate it as follows.

2044
01:36:51,030 --> 01:36:52,030
中文字幕
Here's my main function.

2045
01:36:52,030 --> 01:36:55,120
中文字幕
I'm going to call variable x, give it 1, call variable y,

2046
01:36:55,120 --> 01:36:58,470
中文字幕
give it 2, go ahead and just print out just for a quick sanity check--

2047
01:36:58,470 --> 01:37:00,580
中文字幕
x is this, y is that.

2048
01:37:00,580 --> 01:37:04,390
中文字幕
Then I'm going to call this super simple swap function, x, y.

2049
01:37:04,390 --> 01:37:08,050
中文字幕
Then I'm going to print the exact same thing-- x is this, y is that,

2050
01:37:08,050 --> 01:37:09,650
中文字幕
just so I can see in those variables--

2051
01:37:09,650 --> 01:37:12,250
中文字幕
I could also use debug50, but this is meant to be a complete solution,

2052
01:37:12,250 --> 01:37:13,600
中文字幕
I want to see it on the screen.

2053
01:37:13,600 --> 01:37:14,410
中文字幕
Here is swap.

2054
01:37:14,410 --> 01:37:16,360
中文字幕
I copy-pasted that from before.

2055
01:37:16,360 --> 01:37:18,610
中文字幕
This feels like a no-brainer, super straightforward,

2056
01:37:18,610 --> 01:37:23,770
中文字幕
let's go into my directory and compile this program, which, slight spoiler,

2057
01:37:23,770 --> 01:37:26,590
中文字幕
noswap is the name.

2058
01:37:26,590 --> 01:37:29,730
中文字幕
./noswap.

2059
01:37:29,730 --> 01:37:32,180
中文字幕
Oof.

2060
01:37:32,180 --> 01:37:33,830
中文字幕
Let's zoom in.

2061
01:37:33,830 --> 01:37:35,630
中文字幕
Nope, that is not what I intended, right?

2062
01:37:35,630 --> 01:37:38,380
中文字幕
I really intended milk to become OJ, OJ to become milk,

2063
01:37:38,380 --> 01:37:41,950
中文字幕
or x become y, y become x, this doesn't seem to work.

2064
01:37:41,950 --> 01:37:44,750
中文字幕
And again, the only magic is this one call to swap.

2065
01:37:44,750 --> 01:37:46,750
中文字幕
All right, maybe it just works some of the time.

2066
01:37:46,750 --> 01:37:49,050
中文字幕
So nope, nope-- OK.

2067
01:37:49,050 --> 01:37:50,350
中文字幕
Now it's time for the debugger.

2068
01:37:50,350 --> 01:37:52,390
中文字幕
I don't understand what's going on in my program,

2069
01:37:52,390 --> 01:37:54,430
中文字幕
printf is not really illuminating here.

2070
01:37:54,430 --> 01:37:58,530
中文字幕
So let me go ahead and run debug50 ./noswap.

2071
01:37:58,530 --> 01:38:00,660
中文字幕
The little debugging panels get opened on the side,

2072
01:38:00,660 --> 01:38:02,440
中文字幕
but wait, I need a breakpoint.

2073
01:38:02,440 --> 01:38:05,660
中文字幕
I'm going to start a breakpoint at the very top, the first line I care about.

2074
01:38:05,660 --> 01:38:08,050
中文字幕
I don't really care about all the stuff at the super top.

2075
01:38:08,050 --> 01:38:12,330
中文字幕
Now I'm going to go ahead and rerun debug50 ./noswap, all right?

2076
01:38:12,330 --> 01:38:15,680
中文字幕
Now I see over here, the first line 9 is highlighted.

2077
01:38:15,680 --> 01:38:17,640
中文字幕
Notice on the right-hand side, and this perhaps

2078
01:38:17,640 --> 01:38:19,890
中文字幕
answers by example your question earlier.

2079
01:38:19,890 --> 01:38:23,490
中文字幕
x and y conveniently, but just because we're initialized to 0--

2080
01:38:23,490 --> 01:38:26,500
中文字幕
not by me, I shouldn't necessarily trust this in all contexts,

2081
01:38:26,500 --> 01:38:28,160
中文字幕
but that's why they had values.

2082
01:38:28,160 --> 01:38:31,500
中文字幕
They're otherwise known as garbage values, but I got lucky with 0's here.

2083
01:38:31,500 --> 01:38:34,500
中文字幕
Let me go ahead and step over that line, and if you watch, albeit small,

2084
01:38:34,500 --> 01:38:39,070
中文字幕
on the right-hand side, x should suddenly take on a value of 1.

2085
01:38:39,070 --> 01:38:43,170
中文字幕
And if I step over one more line, y should take on a value of 2.

2086
01:38:43,170 --> 01:38:45,930
中文字幕
OK, so I'm pretty confident the program is thus far correct.

2087
01:38:45,930 --> 01:38:48,390
中文字幕
I'm going to go ahead and step over printf.

2088
01:38:48,390 --> 01:38:51,460
中文字幕
And notice the blue terminal window, I see one output.

2089
01:38:51,460 --> 01:38:53,010
中文字幕
Now things get interesting.

2090
01:38:53,010 --> 01:38:56,700
中文字幕
If I continue stepping over lines, it's just going to finish running

2091
01:38:56,700 --> 01:38:58,020
中文字幕
and that's not enough.

2092
01:38:58,020 --> 01:39:01,890
中文字幕
So notice this time I'm going to hover over this third icon, Step Into.

2093
01:39:01,890 --> 01:39:03,670
中文字幕
Now I can kind of go down the rabbit hole,

2094
01:39:03,670 --> 01:39:07,110
中文字幕
so to speak, and go into the swap function, and notice,

2095
01:39:07,110 --> 01:39:09,430
中文字幕
the debugger jumps into that other function.

2096
01:39:09,430 --> 01:39:11,400
中文字幕
So here now, the context changed.

2097
01:39:11,400 --> 01:39:15,570
中文字幕
My local variables are now a, b, and tmp, and this is really weird.

2098
01:39:15,570 --> 01:39:21,000
中文字幕
A is 1, b is 2, as expected, because I passed an x, y.

2099
01:39:21,000 --> 01:39:25,380
中文字幕
And in the context of this function I'm just calling them a, b because.

2100
01:39:25,380 --> 01:39:29,450
中文字幕
But why is tmp 32,767?

2101
01:39:29,450 --> 01:39:31,950
中文字幕
It's just because it can't be trusted, it's a garbage value.

2102
01:39:31,950 --> 01:39:35,760
中文字幕
If you just give yourself a temporary value, who knows what's in there?

2103
01:39:35,760 --> 01:39:38,250
中文字幕
We got lucky and Tara did not have anything in this cup,

2104
01:39:38,250 --> 01:39:41,370
中文字幕
but it could have had a garbage value, maybe it had some Pepsi,

2105
01:39:41,370 --> 01:39:44,100
中文字幕
and then we would have had to replace that value somehow.

2106
01:39:44,100 --> 01:39:47,130
中文字幕
So to be clear, when you declare variables in a program,

2107
01:39:47,130 --> 01:39:50,430
中文字幕
quite often they have garbage values, just bogus values--

2108
01:39:50,430 --> 01:39:53,620
中文字幕
the 0's and 1's that are there underneath the hood in that chip,

2109
01:39:53,620 --> 01:39:55,020
中文字幕
but that you didn't set yourself.

2110
01:39:55,020 --> 01:39:59,550
中文字幕
But that's OK, because I'm explicitly in this next line setting tmp equal to a.

2111
01:39:59,550 --> 01:40:03,990
中文字幕
So it doesn't matter what its original weird value was, so if I click Next,

2112
01:40:03,990 --> 01:40:06,160
中文字幕
tmp is now 1, a.k.a.

2113
01:40:06,160 --> 01:40:07,500
中文字幕
a.

2114
01:40:07,500 --> 01:40:11,230
中文字幕
Now notice a is going to become b if you watch the right-hand side.

2115
01:40:11,230 --> 01:40:15,480
中文字幕
Now I seem to have a is 2, b is 2, which is a little worrisome but not as bad,

2116
01:40:15,480 --> 01:40:18,570
中文字幕
because I have that separate variable tmp, so I still have the one around.

2117
01:40:18,570 --> 01:40:22,770
中文字幕
So now b is about to become 1, and I've done the switcheroo.

2118
01:40:22,770 --> 01:40:27,870
中文字幕
OK, at this point in the story, line 22, my code seems correct.

2119
01:40:27,870 --> 01:40:30,750
中文字幕
b has become a, a has become b, and the values are swapped--

2120
01:40:30,750 --> 01:40:34,650
中文字幕
and the debugger is confirming that for me visually.

2121
01:40:34,650 --> 01:40:39,900
中文字幕
So now, let's do a step and--

2122
01:40:39,900 --> 01:40:42,560
中文字幕
dammit.

2123
01:40:42,560 --> 01:40:43,990
中文字幕
Lost.

2124
01:40:43,990 --> 01:40:45,820
中文字幕
What is going on?

2125
01:40:45,820 --> 01:40:46,600
中文字幕
Intuitively?

2126
01:40:46,600 --> 01:40:53,010
中文字幕
Even if you've never seen or done this before, like clearly there's a bug.

2127
01:40:53,010 --> 01:40:55,170
中文字幕
What is that bug?

2128
01:40:55,170 --> 01:40:56,130
中文字幕
What must be happening?

2129
01:40:56,130 --> 01:40:57,090
中文字幕
Yeah?

2130
01:40:57,090 --> 01:41:01,830
中文字幕
a new value

2131
01:41:01,830 --> 01:41:03,830
中文字幕
doesn't have the same address for the first one?

2132
01:41:03,830 --> 01:41:04,580
中文字幕
Yeah.

2133
01:41:04,580 --> 01:41:07,480
中文字幕
What seems to be happening here is yes, you're passing in x and y

2134
01:41:07,480 --> 01:41:12,190
中文字幕
and calling it a and b, but a and b would seem to be copies of x and y.

2135
01:41:12,190 --> 01:41:16,060
中文字幕
And I am very successfully, very correctly swapping a and b,

2136
01:41:16,060 --> 01:41:20,170
中文字幕
but because they're copies, it has no effect on the original x and y.

2137
01:41:20,170 --> 01:41:22,810
中文字幕
So our metaphor here of juice isn't quite apt

2138
01:41:22,810 --> 01:41:27,250
中文字幕
because I didn't pass Kelly copies of the OJ and milk,

2139
01:41:27,250 --> 01:41:31,630
中文字幕
I handed her the actual OJ and milk and she was able to change the values.

2140
01:41:31,630 --> 01:41:35,290
中文字幕
But in the context of C and code, when you pass arguments to a function,

2141
01:41:35,290 --> 01:41:38,300
中文字幕
you're passing copies of those arguments to the function.

2142
01:41:38,300 --> 01:41:40,930
中文字幕
So intuitively, what is the solution?

2143
01:41:40,930 --> 01:41:44,980
中文字幕
We clearly cannot pass from one function to another copies of the values if we

2144
01:41:44,980 --> 01:41:47,920
中文字幕
expect the function swap, or a.k.a.

2145
01:41:47,920 --> 01:41:50,720
中文字幕
Kelly, to make some useful change for us.

2146
01:41:50,720 --> 01:41:55,090
中文字幕
What do we have to pass to the function or to Kelly instead?

2147
01:41:55,090 --> 01:41:57,370
中文字幕
The addresses of those values, right?

2148
01:41:57,370 --> 01:41:59,950
中文字幕
I told her where the milk and OJ were.

2149
01:41:59,950 --> 01:42:02,710
中文字幕
I didn't give her copies of them, I told her, here's the milk,

2150
01:42:02,710 --> 01:42:04,740
中文字幕
here's the OJ, swap those.

2151
01:42:04,740 --> 01:42:06,580
中文字幕
In this version of the code, I've just said,

2152
01:42:06,580 --> 01:42:10,570
中文字幕
here's a copy of x, here's a copy of y, you can call them a and b-- um-mmm.

2153
01:42:10,570 --> 01:42:14,660
中文字幕
We need to now use the ampersand or something like that to pass in a map,

2154
01:42:14,660 --> 01:42:15,160
中文字幕
if you will.

2155
01:42:15,160 --> 01:42:20,020
中文字幕
The treasure map to those values so that swap can change the original values.

2156
01:42:20,020 --> 01:42:22,660
中文字幕
And the way we do this is a little weird-looking,

2157
01:42:22,660 --> 01:42:27,640
中文字幕
but all we're going to have to do is make a little addition here

2158
01:42:27,640 --> 01:42:29,830
中文字幕
that looks as follows.

2159
01:42:29,830 --> 01:42:33,320
中文字幕
It's got to look like this instead.

2160
01:42:33,320 --> 01:42:35,170
中文字幕
So this is the broken version.

2161
01:42:35,170 --> 01:42:39,070
中文字幕
Or broken in that it doesn't have the effect we intend even though it works.

2162
01:42:39,070 --> 01:42:41,530
中文字幕
This is what we need to do instead, and it's the last piece

2163
01:42:41,530 --> 01:42:42,990
中文字幕
of new symbology for today.

2164
01:42:42,990 --> 01:42:44,950
中文字幕
We've seen star in a couple of different places

2165
01:42:44,950 --> 01:42:47,920
中文字幕
before, now we're using it in one final context.

2166
01:42:47,920 --> 01:42:53,080
中文字幕
When you specify a star here and here in the arguments to a function, that

2167
01:42:53,080 --> 01:42:55,120
中文字幕
is just the way you tell the computer, I'm

2168
01:42:55,120 --> 01:42:57,820
中文字幕
expecting not an int, but the address of an int.

2169
01:42:57,820 --> 01:43:00,320
中文字幕
I'm expecting not an int here, but the address of an int.

2170
01:43:00,320 --> 01:43:03,520
中文字幕
So two pointers, two addresses of integers.

2171
01:43:03,520 --> 01:43:05,860
中文字幕
Down here, tmp is still just an int.

2172
01:43:05,860 --> 01:43:08,630
中文字幕
I don't need to over think tmp, that's just an empty cup.

2173
01:43:08,630 --> 01:43:11,410
中文字幕
Give me an integer called tmp from week 1.

2174
01:43:11,410 --> 01:43:14,230
中文字幕
But, what do I want to store in tmp?

2175
01:43:14,230 --> 01:43:17,140
中文字幕
Both a and b in this version are addresses.

2176
01:43:17,140 --> 01:43:22,370
中文字幕
Do I want to remember the address a and the address b?

2177
01:43:22,370 --> 01:43:25,460
中文字幕
No, I want to remember the volume of OJ, the volume of milk,

2178
01:43:25,460 --> 01:43:29,780
中文字幕
I want to remember 1 and 2, I don't care where in memory they are.

2179
01:43:29,780 --> 01:43:34,460
中文字幕
So star in this context, when there's no mention of a data type,

2180
01:43:34,460 --> 01:43:37,110
中文字幕
there's just a star and a variable name.

2181
01:43:37,110 --> 01:43:39,410
中文字幕
That variable is a pointer and it's not multiplication,

2182
01:43:39,410 --> 01:43:40,960
中文字幕
there's no math going on.

2183
01:43:40,960 --> 01:43:46,340
中文字幕
That star is the dereference operator that says, go to this address

2184
01:43:46,340 --> 01:43:48,030
中文字幕
and get the value there.

2185
01:43:48,030 --> 01:43:52,070
中文字幕
So if this address a is at location, I don't know, 100 like Brian was,

2186
01:43:52,070 --> 01:43:55,400
中文字幕
and this address b is at location 900 like Veronica was,

2187
01:43:55,400 --> 01:44:01,160
中文字幕
*a means go to the 100th byte in memory and get me that value, which is 1.

2188
01:44:01,160 --> 01:44:05,990
中文字幕
This means, down here, go to the address b, get me that value at address 900,

2189
01:44:05,990 --> 01:44:07,580
中文字幕
which is 2.

2190
01:44:07,580 --> 01:44:10,670
中文字幕
And go ahead and store 1 in tmp.

2191
01:44:10,670 --> 01:44:13,490
中文字幕
Go ahead and go to that address and put whatever's

2192
01:44:13,490 --> 01:44:17,300
中文字幕
at b's address-- so get that address and put it over-- get that address,

2193
01:44:17,300 --> 01:44:20,840
中文字幕
get the value, and put it over at that address by dereferencing.

2194
01:44:20,840 --> 01:44:26,310
中文字幕
And then lastly, go to b in memory, like over there, put the tmp value there.

2195
01:44:26,310 --> 01:44:28,910
中文字幕
So whereas ampersand in our previous example means,

2196
01:44:28,910 --> 01:44:32,690
中文字幕
tell me what the address is of a variable, star is the opposite.

2197
01:44:32,690 --> 01:44:35,360
中文字幕
When you have an address, it says, go to that address.

2198
01:44:35,360 --> 01:44:39,410
中文字幕
Follow the treasure map, X marks the spot at that location in memory,

2199
01:44:39,410 --> 01:44:40,950
中文字幕
and get at its value.

2200
01:44:40,950 --> 01:44:42,850
中文字幕
So what is the net effect here?

2201
01:44:42,850 --> 01:44:46,850
中文字幕
If I actually now open up not this example, but swap.c--

2202
01:44:46,850 --> 01:44:50,030
中文字幕
spoiler, this one is going to actually work.

2203
01:44:50,030 --> 01:44:55,490
中文字幕
If I open up swap.c, we're going to see now the following instead.

2204
01:44:55,490 --> 01:44:58,600
中文字幕
The code is almost the same, except that I pasted it

2205
01:44:58,600 --> 01:45:01,160
中文字幕
in this new green version of the function.

2206
01:45:01,160 --> 01:45:03,200
中文字幕
And notice here, this had a change.

2207
01:45:03,200 --> 01:45:11,860
中文字幕
Why am I typing in %x now and %y instead of just x and y?

2208
01:45:11,860 --> 01:45:17,200
中文字幕
address [INAUDIBLE] functions [INAUDIBLE]..

2209
01:45:17,200 --> 01:45:18,190
中文字幕
Exactly.

2210
01:45:18,190 --> 01:45:20,140
中文字幕
The swap function now, the new improved version

2211
01:45:20,140 --> 01:45:22,840
中文字幕
is expected two addresses-- stars.

2212
01:45:22,840 --> 01:45:25,840
中文字幕
Each star, a.k.a. pointers, not just values.

2213
01:45:25,840 --> 01:45:29,800
中文字幕
So this means I know x and y are actually integers from week 1.

2214
01:45:29,800 --> 01:45:31,990
中文字幕
Now I need the address of x and the address of y

2215
01:45:31,990 --> 01:45:35,270
中文字幕
so that swap can follow those treasure maps,

2216
01:45:35,270 --> 01:45:37,580
中文字幕
so to speak, and go to those addresses.

2217
01:45:37,580 --> 01:45:42,250
中文字幕
So now, when I run this program, this is more like the metaphor with Kelly

2218
01:45:42,250 --> 01:45:44,290
中文字幕
where I told her where the milk and OJ were.

2219
01:45:44,290 --> 01:45:48,760
中文字幕
Now swap and go to those locations as follows. make swap.

2220
01:45:48,760 --> 01:45:51,950
中文字幕
Let me go ahead and then do ./swap, Enter--

2221
01:45:51,950 --> 01:45:52,630
中文字幕
ah!

2222
01:45:52,630 --> 01:45:54,460
中文字幕
Now it seems to be working.

2223
01:45:54,460 --> 01:45:56,380
中文字幕
And we can see as much even with the debugger.

2224
01:45:56,380 --> 01:45:59,650
中文字幕
Even though it doesn't seem to be buggy, I can still use debug50

2225
01:45:59,650 --> 01:46:03,040
中文字幕
to see and understand my program, if not obvious-- oh,

2226
01:46:03,040 --> 01:46:04,180
中文字幕
I still need a breakpoint.

2227
01:46:04,180 --> 01:46:05,890
中文字幕
Let's set a breakpoint as before.

2228
01:46:05,890 --> 01:46:07,870
中文字幕
Let's rerun debug50.

2229
01:46:07,870 --> 01:46:11,110
中文字幕
The right-hand panel will open automatically for me.

2230
01:46:11,110 --> 01:46:14,590
中文字幕
And let's go ahead and see, if I start stepping over this,

2231
01:46:14,590 --> 01:46:23,280
中文字幕
now I see that x is 1, y is 2, printf prints as much on the screen.

2232
01:46:23,280 --> 01:46:25,980
中文字幕
Now I'm going to go ahead and step into swap,

2233
01:46:25,980 --> 01:46:28,760
中文字幕
and now notice, it's a little weird-looking,

2234
01:46:28,760 --> 01:46:32,420
中文字幕
because now a is an address and b is an address,

2235
01:46:32,420 --> 01:46:36,530
中文字幕
but tmp is still an int with a garbage value, but I can fix that.

2236
01:46:36,530 --> 01:46:41,700
中文字幕
Now tmp is 1, but notice, a and b's values are not changing,

2237
01:46:41,700 --> 01:46:43,910
中文字幕
but what is clearly changing per the code?

2238
01:46:46,660 --> 01:46:48,760
中文字幕
So notice, this is weird and cryptic.

2239
01:46:48,760 --> 01:46:50,740
中文字幕
a is this 0x value.

2240
01:46:50,740 --> 01:46:54,550
中文字幕
That's a big hexadecimal address, like that is where in memory a is.

2241
01:46:54,550 --> 01:46:55,300
中文字幕
But you know what?

2242
01:46:55,300 --> 01:46:58,620
中文字幕
If I click the little triangle, I can kind of follow that pointer

2243
01:46:58,620 --> 01:46:59,350
中文字幕
and go to it.

2244
01:46:59,350 --> 01:47:01,120
中文字幕
The debugger is smart like that.

2245
01:47:01,120 --> 01:47:06,820
中文字幕
So *a, go to a is 2; and *b at the moment is 2, but if I keep going,

2246
01:47:06,820 --> 01:47:11,240
中文字幕
now I've done a switcheroo, and you can see that these values have changed.

2247
01:47:11,240 --> 01:47:13,330
中文字幕
And again, we don't care what these addresses are,

2248
01:47:13,330 --> 01:47:15,010
中文字幕
I don't care what the actual addresses are.

2249
01:47:15,010 --> 01:47:17,630
中文字幕
I do care that it gives me this functionality, because now when

2250
01:47:17,630 --> 01:47:20,050
中文字幕
I return up here in print, now the values have indeed

2251
01:47:20,050 --> 01:47:23,350
中文字幕
changed as I expected this whole time.

2252
01:47:23,350 --> 01:47:24,070
中文字幕
All right.

2253
01:47:24,070 --> 01:47:30,520
中文字幕
That was complex, but hopefully clear as to why it now works even though we've

2254
01:47:30,520 --> 01:47:33,150
中文字幕
made this code look more cryptic.

2255
01:47:33,150 --> 01:47:34,990
中文字幕
If not, any questions are welcome.

2256
01:47:34,990 --> 01:47:35,640
中文字幕
Yeah?

2257
01:47:35,640 --> 01:47:39,610
中文字幕
AUDIENCE: Is that from the spot where [INAUDIBLE]

2258
01:47:39,610 --> 01:47:40,450
中文字幕
Uh huh.

2259
01:47:40,450 --> 01:47:44,880
中文字幕
the star [INAUDIBLE] pointers?

2260
01:47:44,880 --> 01:47:46,010
中文字幕
Good question.

2261
01:47:46,010 --> 01:47:49,960
中文字幕
Do we really need to have these ampersands here because we already

2262
01:47:49,960 --> 01:47:50,920
中文字幕
have the stars here?

2263
01:47:50,920 --> 01:47:52,630
中文字幕
Short answer, yes, for symmetry.

2264
01:47:52,630 --> 01:47:55,660
中文字幕
This is telling the function what to expect on the way in;

2265
01:47:55,660 --> 01:48:00,600
中文字幕
this is what's telling the computer actually what to send in.

2266
01:48:00,600 --> 01:48:03,420
中文字幕
So what are the actual inputs to that function?

2267
01:48:03,420 --> 01:48:05,370
中文字幕
It has to be symmetric.

2268
01:48:05,370 --> 01:48:05,960
中文字幕
Yeah?

2269
01:48:05,960 --> 01:48:11,530
中文字幕
value is swapping addresses.

2270
01:48:11,530 --> 01:48:16,110
中文字幕
We are swapping what is at the addresses.

2271
01:48:16,110 --> 01:48:24,870
中文字幕
AUDIENCE: So what if you change the address of [INAUDIBLE]

2272
01:48:24,870 --> 01:48:25,530
中文字幕
OK.

2273
01:48:25,530 --> 01:48:29,000
中文字幕
AUDIENCE: And would we swap the addresses saying 2 is at 200 and 1

2274
01:48:29,000 --> 01:48:31,830
中文字幕
is at [INAUDIBLE] that could change.

2275
01:48:31,830 --> 01:48:35,970
中文字幕
Short answer, you cannot for the following reason.

2276
01:48:35,970 --> 01:48:41,220
中文字幕
So technically, when you do %x and %y, these are converted to the address

2277
01:48:41,220 --> 01:48:42,540
中文字幕
of x, the address of y.

2278
01:48:42,540 --> 01:48:46,770
中文字幕
Technically swap is getting copies of something, C has not changed.

2279
01:48:46,770 --> 01:48:49,740
中文字幕
But C is now getting copies of the address

2280
01:48:49,740 --> 01:48:53,940
中文字幕
of x, copies of the address of y, calling them a and b.

2281
01:48:53,940 --> 01:48:57,030
中文字幕
So sure, you could swap the addresses, but for the same reasons as before,

2282
01:48:57,030 --> 01:48:58,860
中文字幕
it's going to have no fundamental effect.

2283
01:48:58,860 --> 01:49:01,770
中文字幕
The difference here is because I'm passing in a map, so to speak,

2284
01:49:01,770 --> 01:49:03,420
中文字幕
to x and y, their addresses.

2285
01:49:03,420 --> 01:49:04,830
中文字幕
And again, an address is like--

2286
01:49:04,830 --> 01:49:08,490
中文字幕
we are at 45 Quincy Street I think right now--

2287
01:49:08,490 --> 01:49:10,470
中文字幕
Cambridge, Massachusetts 02138, USA.

2288
01:49:10,470 --> 01:49:12,150
中文字幕
That uniquely identifies the building.

2289
01:49:12,150 --> 01:49:15,820
中文字幕
These 0x hexadecimal numbers uniquely identify locations in memory.

2290
01:49:15,820 --> 01:49:19,350
中文字幕
So this is like saying now, get me the address of x, get me the address of y,

2291
01:49:19,350 --> 01:49:22,680
中文字幕
and I'm technically passing in copies of those addresses, but it doesn't matter,

2292
01:49:22,680 --> 01:49:25,920
中文字幕
because now with the star notation, I'm saying go to those addresses

2293
01:49:25,920 --> 01:49:30,450
中文字幕
and swap who is physically in this building and some other.

2294
01:49:30,450 --> 01:49:31,170
中文字幕
All right.

2295
01:49:31,170 --> 01:49:34,380
中文字幕
So let's just put this now into the context of what else

2296
01:49:34,380 --> 01:49:36,180
中文字幕
your computer actually has just that you've

2297
01:49:36,180 --> 01:49:39,340
中文字幕
seen some nomenclature around this computer's memory.

2298
01:49:39,340 --> 01:49:41,700
中文字幕
So this is the chip with a grid laid out on top of it

2299
01:49:41,700 --> 01:49:44,700
中文字幕
just to communicate that there's bytes here, and we could number them.

2300
01:49:44,700 --> 01:49:47,160
中文字幕
But let's think about this now more abstractly,

2301
01:49:47,160 --> 01:49:49,890
中文字幕
and let me just reveal that it turns out that the computer treats

2302
01:49:49,890 --> 01:49:53,910
中文字幕
different bytes, different squares in different ways just by convention.

2303
01:49:53,910 --> 01:49:56,040
中文字幕
It turns out that in your computer's memory--

2304
01:49:56,040 --> 01:49:58,590
中文字幕
and this is all just an artist's representation--

2305
01:49:58,590 --> 01:50:01,390
中文字幕
at the top of that chip of memory, so to speak,

2306
01:50:01,390 --> 01:50:03,130
中文字幕
is the so-called text of your program.

2307
01:50:03,130 --> 01:50:05,250
中文字幕
This is a fancy and non-obvious way of saying

2308
01:50:05,250 --> 01:50:09,540
中文字幕
the 0's and 1's that your code have has been compiled into.

2309
01:50:09,540 --> 01:50:12,530
中文字幕
The text of a program is the code you wrote in binary,

2310
01:50:12,530 --> 01:50:14,080
中文字幕
that's where it's loaded from memory.

2311
01:50:14,080 --> 01:50:16,290
中文字幕
So in macOS and Windows, you double-click an icon,

2312
01:50:16,290 --> 01:50:18,540
中文字幕
that program is loaded into memory I said last week.

2313
01:50:18,540 --> 01:50:22,920
中文字幕
It's literally loaded into the top of your computer's memory conceptually.

2314
01:50:22,920 --> 01:50:23,610
中文字幕
What else?

2315
01:50:23,610 --> 01:50:29,460
中文字幕
Well the heap is the fancy name given to the chunk of memory in which memory

2316
01:50:29,460 --> 01:50:31,140
中文字幕
is coming from when you call malloc.

2317
01:50:31,140 --> 01:50:34,740
中文字幕
So when I called malloc earlier to get a bunch of space for some characters,

2318
01:50:34,740 --> 01:50:37,800
中文字幕
it was just coming from this big open area called the heap.

2319
01:50:37,800 --> 01:50:41,220
中文字幕
And that's what get_string is using and other functions as well.

2320
01:50:41,220 --> 01:50:44,940
中文字幕
Well it turns out that the reason for the problem we just ran into

2321
01:50:44,940 --> 01:50:48,400
中文字幕
is because the bottom part of memory is what's called the stack.

2322
01:50:48,400 --> 01:50:52,650
中文字幕
The stack is the area of memory that functions use when they are called.

2323
01:50:52,650 --> 01:50:57,640
中文字幕
And this is actually relevant to that very simple noswap example as follows.

2324
01:50:57,640 --> 01:51:01,800
中文字幕
If we now assume that anytime you call a function, the memory it uses

2325
01:51:01,800 --> 01:51:04,700
中文字幕
comes from the bottom of that big block of memory,

2326
01:51:04,700 --> 01:51:07,500
中文字幕
where you can draw that, for instance, here on the screen,

2327
01:51:07,500 --> 01:51:10,560
中文字幕
because it turns out that anytime you call a function, that function gets

2328
01:51:10,560 --> 01:51:12,060
中文字幕
a slice of its own memory.

2329
01:51:12,060 --> 01:51:15,660
中文字幕
So for instance, main is always the first program a function calls,

2330
01:51:15,660 --> 01:51:20,910
中文字幕
and so it gets the first slice of memory at the bottom of the screen here.

2331
01:51:20,910 --> 01:51:25,030
中文字幕
And so if main had two variables x and y, that's like saying,

2332
01:51:25,030 --> 01:51:29,770
中文字幕
OK, give me a chunk of memory called x and put the value 1 in it;

2333
01:51:29,770 --> 01:51:33,690
中文字幕
give me another chunk of memory, call it y, put a value in it here.

2334
01:51:33,690 --> 01:51:38,850
中文字幕
But remember, from the first noswap example, the swap function was called.

2335
01:51:38,850 --> 01:51:40,430
中文字幕
This is a stack in the literal sense.

2336
01:51:40,430 --> 01:51:44,140
中文字幕
You go into a dining hall, a cafeteria, one tray for food, goes on another,

2337
01:51:44,140 --> 01:51:46,770
中文字幕
goes on another, goes on another so that the humans can take it

2338
01:51:46,770 --> 01:51:48,240
中文字幕
and put food and plates on it.

2339
01:51:48,240 --> 01:51:51,270
中文字幕
Well similarly in this model, when you call a function,

2340
01:51:51,270 --> 01:51:55,200
中文字幕
it gets its own slice of memory, but literally above, conceptually,

2341
01:51:55,200 --> 01:51:58,230
中文字幕
the existing frame on the stack.

2342
01:51:58,230 --> 01:52:01,620
中文字幕
So this is the swap function's own chunk of memory,

2343
01:52:01,620 --> 01:52:03,650
中文字幕
and it, too, gets some space.

2344
01:52:03,650 --> 01:52:06,030
中文字幕
It gets some space for a variable called a.

2345
01:52:06,030 --> 01:52:08,670
中文字幕
It gets some space for a variable called b.

2346
01:52:08,670 --> 01:52:11,700
中文字幕
And guess what goes inside those of that first example?

2347
01:52:11,700 --> 01:52:15,210
中文字幕
A copy of x and a copy of y.

2348
01:52:15,210 --> 01:52:15,960
中文字幕
And you know what?

2349
01:52:15,960 --> 01:52:19,140
中文字幕
It had a temp variable, so that's got to have some space here.

2350
01:52:19,140 --> 01:52:20,940
中文字幕
So I'll call this tmp.

2351
01:52:20,940 --> 01:52:24,720
中文字幕
And recall that I set tmp equal to a, so that got 1.

2352
01:52:24,720 --> 01:52:25,750
中文字幕
And then what happened?

2353
01:52:25,750 --> 01:52:27,970
中文字幕
Well then I did what--

2354
01:52:27,970 --> 01:52:30,730
中文字幕
what did I?

2355
01:52:30,730 --> 01:52:33,630
中文字幕
Let me get this right.

2356
01:52:33,630 --> 01:52:36,180
中文字幕
We had a gets b.

2357
01:52:36,180 --> 01:52:38,920
中文字幕
So what happened there?

2358
01:52:38,920 --> 01:52:43,440
中文字幕
So in this example here, a gets the value b, so that changed.

2359
01:52:43,440 --> 01:52:46,770
中文字幕
And then what happens here, b got the value of 10, so that changed.

2360
01:52:46,770 --> 01:52:49,890
中文字幕
So swap was working in the sense that it was swapping values,

2361
01:52:49,890 --> 01:52:53,280
中文字幕
but the problem is, when a function returns, this chunk of memory that it

2362
01:52:53,280 --> 01:52:58,900
中文字幕
was previously using gets reclaimed so that someone else can now use it,

2363
01:52:58,900 --> 01:52:59,710
中文字幕
another function.

2364
01:52:59,710 --> 01:53:03,000
中文字幕
So we did all that hard work and no swap, and we did it correctly,

2365
01:53:03,000 --> 01:53:05,980
中文字幕
we just did it in the wrong place.

2366
01:53:05,980 --> 01:53:11,210
中文字幕
So by contrast, this next example that we did, which was swap.c,

2367
01:53:11,210 --> 01:53:13,260
中文字幕
just treated the memory a little bit differently.

2368
01:53:13,260 --> 01:53:18,210
中文字幕
Main this time still had two variables called x, and this was a 1,

2369
01:53:18,210 --> 01:53:21,300
中文字幕
and then another one called y, and this was a 2.

2370
01:53:21,300 --> 01:53:23,760
中文字幕
And then one swap was called this time, it again

2371
01:53:23,760 --> 01:53:26,520
中文字幕
had a variable called a and a variable called

2372
01:53:26,520 --> 01:53:29,790
中文字幕
b, but what was stored in a and b?

2373
01:53:29,790 --> 01:53:30,920
中文字幕
Well now they're addresses.

2374
01:53:30,920 --> 01:53:34,390
中文字幕
And I don't know what it is, but let me just arbitrarily say that this

2375
01:53:34,390 --> 01:53:37,240
中文字幕
is location 100, this is location--

2376
01:53:37,240 --> 01:53:39,280
中文字幕
let's say 104.

2377
01:53:39,280 --> 01:53:41,740
中文字幕
But it could be anything, we just don't care at this point,

2378
01:53:41,740 --> 01:53:44,590
中文字幕
it would have 0x technically if the computer were showing us.

2379
01:53:44,590 --> 01:53:49,750
中文字幕
What's going in a here is 100, what's going in b here is 104.

2380
01:53:49,750 --> 01:53:54,040
中文字幕
And those are the addresses of x and y, and the code

2381
01:53:54,040 --> 01:53:56,410
中文字幕
we had using all of those new stars was saying,

2382
01:53:56,410 --> 01:54:04,030
中文字幕
go to address 100 and store whatever is at address 100 in tmp.

2383
01:54:04,030 --> 01:54:07,450
中文字幕
Then go to the address that's in b, or 104,

2384
01:54:07,450 --> 01:54:12,850
中文字幕
and store that at the location int *a, whatever is there.

2385
01:54:12,850 --> 01:54:15,430
中文字幕
Then it was saying, go get that 10th value, by the way,

2386
01:54:15,430 --> 01:54:20,500
中文字幕
and go ahead and put that here, so that now we did

2387
01:54:20,500 --> 01:54:23,300
中文字幕
different work in a different place.

2388
01:54:23,300 --> 01:54:25,870
中文字幕
So now when swap is done running, it doesn't

2389
01:54:25,870 --> 01:54:31,520
中文字幕
matter if its memory disappears because it has now mutated or changed

2390
01:54:31,520 --> 01:54:32,260
中文字幕
the other memory.

2391
01:54:32,260 --> 01:54:35,560
中文字幕
That it was passed in just like Kelly changed or mutated the cups

2392
01:54:35,560 --> 01:54:39,680
中文字幕
I actually pointed her at rather than copies thereof.

2393
01:54:39,680 --> 01:54:43,300
中文字幕
Now as an aside, there's other chunks of memory that are actually used.

2394
01:54:43,300 --> 01:54:45,760
中文字幕
If you have global variables in a program,

2395
01:54:45,760 --> 01:54:48,040
中文字幕
turns out that in between the text and the heap

2396
01:54:48,040 --> 01:54:51,310
中文字幕
memory are your global variables, if they're initialized with values

2397
01:54:51,310 --> 01:54:54,740
中文字幕
or they're not initialized with values, as would happen with the equal sign,

2398
01:54:54,740 --> 01:54:56,710
中文字幕
but we don't care too much about that for today's purposes.

2399
01:54:56,710 --> 01:54:58,510
中文字幕
And if you've ever heard of environment variables, which

2400
01:54:58,510 --> 01:55:01,030
中文字幕
we will when we get to web programming, they, too,

2401
01:55:01,030 --> 01:55:02,950
中文字幕
are stored elsewhere in memory.

2402
01:55:02,950 --> 01:55:04,780
中文字幕
But the most interesting chunks of memory

2403
01:55:04,780 --> 01:55:07,910
中文字幕
are stack and heap, as in this case here.

2404
01:55:07,910 --> 01:55:10,560
中文字幕
But unfortunately it's so easy for things to go awry--

2405
01:55:10,560 --> 01:55:13,060
中文字幕
I mean, some of you experienced segmentation faults already,

2406
01:55:13,060 --> 01:55:15,200
中文字幕
and let's consider why that might happen.

2407
01:55:15,200 --> 01:55:18,940
中文字幕
So here's a contrived example of code that is by design buggy,

2408
01:55:18,940 --> 01:55:21,820
中文字幕
but let's just talk it through in English what these lines are doing.

2409
01:55:21,820 --> 01:55:25,390
中文字幕
This line here, int *x, is saying, hey, computer,

2410
01:55:25,390 --> 01:55:31,140
中文字幕
give me a variable that will store the address of an integer.

2411
01:55:31,140 --> 01:55:34,570
中文字幕
So give me a pointer to an int is the more casual way of saying it.

2412
01:55:34,570 --> 01:55:37,940
中文字幕
Hey computer, give me another variable that's

2413
01:55:37,940 --> 01:55:40,250
中文字幕
going to store the address of an int and call it y.

2414
01:55:40,250 --> 01:55:42,170
中文字幕
So x and y, that's it.

2415
01:55:42,170 --> 01:55:44,000
中文字幕
This line is new-ish.

2416
01:55:44,000 --> 01:55:48,510
中文字幕
Hey computer, allocate enough space that will fit an int.

2417
01:55:48,510 --> 01:55:51,560
中文字幕
So sizeof int is the new syntax we saw earlier for just figuring out

2418
01:55:51,560 --> 01:55:52,640
中文字幕
how many bytes is an int.

2419
01:55:52,640 --> 01:55:56,550
中文字幕
Odds are this is going to come back as 4 or 32 bits in most computers.

2420
01:55:56,550 --> 01:55:59,520
中文字幕
So this just says, hey browser, give me 4 bytes of memory

2421
01:55:59,520 --> 01:56:02,750
中文字幕
and store that in this location.

2422
01:56:02,750 --> 01:56:06,140
中文字幕
Or rather, store that in this variable, store that this variable.

2423
01:56:06,140 --> 01:56:09,650
中文字幕
So maybe it's going to say, OK, here's four bytes at location 100,

2424
01:56:09,650 --> 01:56:11,390
中文字幕
or here's four bytes at location 900.

2425
01:56:11,390 --> 01:56:15,670
中文字幕
Or wherever, we don't care, we're just remembering that address in x.

2426
01:56:15,670 --> 01:56:18,460
中文字幕
*x says, go to that address--

2427
01:56:18,460 --> 01:56:22,430
中文字幕
100 or 900, whatever it is, put the number 42 there.

2428
01:56:22,430 --> 01:56:26,760
中文字幕
This next line says, go to the address in y and put the unlucky number-- hint,

2429
01:56:26,760 --> 01:56:27,320
中文字幕
hint--

2430
01:56:27,320 --> 01:56:30,530
中文字幕
13 there.

2431
01:56:30,530 --> 01:56:32,220
中文字幕
Well what is the address in y?

2432
01:56:35,820 --> 01:56:36,950
中文字幕
I haven't allocated it yet.

2433
01:56:36,950 --> 01:56:38,540
中文字幕
What's the address in x?

2434
01:56:38,540 --> 01:56:41,420
中文字幕
It's wherever malloc told me to use space.

2435
01:56:41,420 --> 01:56:44,450
中文字幕
That's safe, that was like 100, 900, whatever the value was,

2436
01:56:44,450 --> 01:56:46,550
中文字幕
but did I allocate space for y?

2437
01:56:46,550 --> 01:56:49,570
中文字幕
So what kind of value does it contain, so to speak?

2438
01:56:49,570 --> 01:56:50,660
中文字幕
A garbage value.

2439
01:56:50,660 --> 01:56:53,640
中文字幕
Maybe it's 0, maybe it's like 32,000-- we don't know,

2440
01:56:53,640 --> 01:56:55,850
中文字幕
because if you don't specify the value, it

2441
01:56:55,850 --> 01:56:59,280
中文字幕
is not safe to trust it or do anything with it.

2442
01:56:59,280 --> 01:57:02,510
中文字幕
This is going to give me probably one of those segmentation faults.

2443
01:57:02,510 --> 01:57:04,550
中文字幕
And indeed, if I run a program like this,

2444
01:57:04,550 --> 01:57:08,510
中文字幕
I'm quite likely going to see exactly that kind of problem.

2445
01:57:08,510 --> 01:57:10,810
中文字幕
It's perhaps better, though, to see this in a way that

2446
01:57:10,810 --> 01:57:14,040
中文字幕
will paint a more memorable picture, and for that, thought we'd take--

2447
01:57:14,040 --> 01:57:16,340
中文字幕
in our 10 minutes remaining, use a few of these minutes

2448
01:57:16,340 --> 01:57:18,460
中文字幕
to take a look at something our friends at Stanford

2449
01:57:18,460 --> 01:57:20,070
中文字幕
put together with a bit of claymation.

2450
01:57:20,070 --> 01:57:22,390
中文字幕
It's about three minutes long, well worth it

2451
01:57:22,390 --> 01:57:24,650
中文字幕
to paint a picture of exactly what goes wrong

2452
01:57:24,650 --> 01:57:27,250
中文字幕
when you don't use memory correctly.

2453
01:57:27,250 --> 01:57:29,130
中文字幕
If you could dim the lights.

2454
01:57:29,130 --> 01:57:29,790
中文字幕
[VIDEO PLAYBACK]

2455
01:57:29,790 --> 01:57:32,640
中文字幕
[MUSIC PLAYING]

2456
01:57:32,640 --> 01:57:33,410
中文字幕
- Hey, Binky.

2457
01:57:33,410 --> 01:57:34,220
中文字幕
Wake up!

2458
01:57:34,220 --> 01:57:36,650
中文字幕
It's time for pointer fun!

2459
01:57:36,650 --> 01:57:37,930
中文字幕
- What's that?

2460
01:57:37,930 --> 01:57:39,080
中文字幕
Learn about pointers?

2461
01:57:39,080 --> 01:57:41,300
中文字幕
Oh goody!

2462
01:57:41,300 --> 01:57:44,320
中文字幕
- Well to get started, I guess we're going to need a couple of pointers.

2463
01:57:44,320 --> 01:57:45,140
中文字幕
- OK.

2464
01:57:45,140 --> 01:57:48,660
中文字幕
This code allocates two pointers which can point to integers.

2465
01:57:48,660 --> 01:57:49,160
中文字幕
- OK.

2466
01:57:49,160 --> 01:57:52,880
中文字幕
Well I see the two pointers, but they don't seem to be pointing to anything.

2467
01:57:52,880 --> 01:57:53,720
中文字幕
- That's right.

2468
01:57:53,720 --> 01:57:55,850
中文字幕
Initially pointers don't point to anything.

2469
01:57:55,850 --> 01:57:58,100
中文字幕
The things they point to are called pointees,

2470
01:57:58,100 --> 01:58:00,050
中文字幕
and setting them up to a separate step.

2471
01:58:00,050 --> 01:58:00,950
中文字幕
- Oh right, right.

2472
01:58:00,950 --> 01:58:01,700
中文字幕
I knew that.

2473
01:58:01,700 --> 01:58:03,470
中文字幕
The pointees are separate.

2474
01:58:03,470 --> 01:58:05,980
中文字幕
So how do you allocate a pointee?

2475
01:58:05,980 --> 01:58:06,680
中文字幕
- OK.

2476
01:58:06,680 --> 01:58:09,740
中文字幕
Well this code allocates a new integer pointee,

2477
01:58:09,740 --> 01:58:12,890
中文字幕
and this part sets x to point to it.

2478
01:58:12,890 --> 01:58:14,060
中文字幕
- Hey, that looks better.

2479
01:58:14,060 --> 01:58:15,510
中文字幕
So make it do something.

2480
01:58:15,510 --> 01:58:16,300
中文字幕
- OK.

2481
01:58:16,300 --> 01:58:21,340
中文字幕
How do you reference the pointer x to store the number 42 into its pointee?

2482
01:58:21,340 --> 01:58:24,880
中文字幕
For this trick, I'll need my magic wand of dereferencing.

2483
01:58:24,880 --> 01:58:27,930
中文字幕
- Your magic wand of dereferencing?

2484
01:58:27,930 --> 01:58:30,040
中文字幕
That-- that's great.

2485
01:58:30,040 --> 01:58:31,840
中文字幕
- This is what the code looks like.

2486
01:58:31,840 --> 01:58:33,590
中文字幕
I'll just set up the number and--

2487
01:58:33,590 --> 01:58:34,770
中文字幕
[POP]

2488
01:58:34,770 --> 01:58:35,440
中文字幕
- Hey look!

2489
01:58:35,440 --> 01:58:36,880
中文字幕
There it goes.

2490
01:58:36,880 --> 01:58:41,740
中文字幕
So doing a dereference on x follows the arrow to access its pointee.

2491
01:58:41,740 --> 01:58:43,900
中文字幕
In this case, to store 42 in there.

2492
01:58:43,900 --> 01:58:48,520
中文字幕
Hey, try using it to store the number 13 through the other pointer, y.

2493
01:58:48,520 --> 01:58:49,510
中文字幕
- OK.

2494
01:58:49,510 --> 01:58:54,010
中文字幕
I'll just go over here to y and get the number 13 set up,

2495
01:58:54,010 --> 01:58:58,020
中文字幕
and then take the wand of dereferencing and just--

2496
01:58:58,020 --> 01:58:59,560
中文字幕
[BUZZING] whoa!

2497
01:58:59,560 --> 01:59:01,780
中文字幕
- Oh hey, that didn't work.

2498
01:59:01,780 --> 01:59:05,420
中文字幕
Say, Binky, I don't think dereferencing y is a good idea,

2499
01:59:05,420 --> 01:59:08,690
中文字幕
cause setting up the pointee is a separate step

2500
01:59:08,690 --> 01:59:10,490
中文字幕
and I don't think we ever did it.

2501
01:59:10,490 --> 01:59:12,230
中文字幕
- Mmm, good point.

2502
01:59:12,230 --> 01:59:12,730
中文字幕
- Yeah.

2503
01:59:12,730 --> 01:59:17,120
中文字幕
We allocated the pointer y, but we never set it to point to a pointee.

2504
01:59:17,120 --> 01:59:19,490
中文字幕
- Mmm, very observant.

2505
01:59:19,490 --> 01:59:21,160
中文字幕
- Hey, you're looking good there, Binky.

2506
01:59:21,160 --> 01:59:24,200
中文字幕
Can you fix it so that y points to the same pointee as x?

2507
01:59:24,200 --> 01:59:24,700
中文字幕
- Sure.

2508
01:59:24,700 --> 01:59:27,520
中文字幕
I'll use my magic wand of pointer assignment.

2509
01:59:27,520 --> 01:59:29,810
中文字幕
- Is that going to be a problem like before?

2510
01:59:29,810 --> 01:59:31,540
中文字幕
- No, this doesn't touch the pointees.

2511
01:59:31,540 --> 01:59:35,110
中文字幕
It just changes one pointer to point to the same thing as another.

2512
01:59:35,110 --> 01:59:36,190
中文字幕
- Oh, I see.

2513
01:59:36,190 --> 01:59:38,770
中文字幕
Now y points to the same place as x.

2514
01:59:38,770 --> 01:59:40,790
中文字幕
So wait, now y is fixed.

2515
01:59:40,790 --> 01:59:41,860
中文字幕
It has a pointee.

2516
01:59:41,860 --> 01:59:46,360
中文字幕
So you can try the wand of dereferencing again to send the 13 over.

2517
01:59:46,360 --> 01:59:47,050
中文字幕
- OK.

2518
01:59:47,050 --> 01:59:48,830
中文字幕
Here goes.

2519
01:59:48,830 --> 01:59:50,080
中文字幕
- Hey, look at that.

2520
01:59:50,080 --> 01:59:51,790
中文字幕
Now dereferencing works on y.

2521
01:59:51,790 --> 01:59:55,920
中文字幕
And because the pointers are sharing that one pointee, they both see the 13.

2522
01:59:55,920 --> 01:59:57,610
中文字幕
- Yeah, sharing, whatever.

2523
01:59:57,610 --> 01:59:59,520
中文字幕
So we going to switch places now?

2524
01:59:59,520 --> 02:00:01,490
中文字幕
- Oh look, we're out of time.

2525
02:00:01,490 --> 02:00:02,060
中文字幕
- But--

2526
02:00:02,060 --> 02:00:02,740
中文字幕
[END PLAYBACK]

2527
02:00:02,740 --> 02:00:03,700
中文字幕
All right.

2528
02:00:03,700 --> 02:00:07,780
中文字幕
So hopefully that puts a little more visual behind some of these ideas,

2529
02:00:07,780 --> 02:00:12,190
中文字幕
but let's now contextualize this in a domain that's perhaps

2530
02:00:12,190 --> 02:00:13,940
中文字幕
more familiar in a couple of ways.

2531
02:00:13,940 --> 02:00:16,030
中文字幕
So one, some of you might already know, especially

2532
02:00:16,030 --> 02:00:18,370
中文字幕
if you've had prior programming experience, of a very popular website

2533
02:00:18,370 --> 02:00:20,320
中文字幕
called Stack Overflow where lots of programmers

2534
02:00:20,320 --> 02:00:24,350
中文字幕
post questions and hopefully answers to common technical problems.

2535
02:00:24,350 --> 02:00:26,650
中文字幕
If you ever wondered why it's called Stack Overflow,

2536
02:00:26,650 --> 02:00:29,290
中文字幕
it turns out it reduces to this picture here.

2537
02:00:29,290 --> 02:00:33,150
中文字幕
This was not a mistake that I drew one arrow from the heap pointing down,

2538
02:00:33,150 --> 02:00:34,960
中文字幕
and one arrow from the stack growing up.

2539
02:00:34,960 --> 02:00:38,160
中文字幕
As you malloc, malloc, malloc more and more space,

2540
02:00:38,160 --> 02:00:41,020
中文字幕
starts up here, so to speak, and you just get more and more space

2541
02:00:41,020 --> 02:00:42,780
中文字幕
that's going this direction.

2542
02:00:42,780 --> 02:00:45,160
中文字幕
But the more functions you call-- function after function

2543
02:00:45,160 --> 02:00:47,030
中文字幕
after function after a function, each of them

2544
02:00:47,030 --> 02:00:50,380
中文字幕
gets its own slice or frame of memory, that, too, is growing up.

2545
02:00:50,380 --> 02:00:54,280
中文字幕
So this feels like a pretty bad design, but honestly, it's not really avoidable

2546
02:00:54,280 --> 02:00:56,200
中文字幕
because if you have a finite amount of memory,

2547
02:00:56,200 --> 02:00:58,510
中文字幕
you can't avoid each other forever.

2548
02:00:58,510 --> 02:01:03,010
中文字幕
And so there's this fundamental risk of overflowing the stack,

2549
02:01:03,010 --> 02:01:06,110
中文字幕
or even overflowing the heap in the reverse direction.

2550
02:01:06,110 --> 02:01:09,520
中文字幕
So Stack Overflow is an allusion to, for instance, calling too

2551
02:01:09,520 --> 02:01:12,190
中文字幕
many-- many, many, many, many, many, many, many, many functions,

2552
02:01:12,190 --> 02:01:15,760
中文字幕
so many so that it overlaps other chunks or segments of memory,

2553
02:01:15,760 --> 02:01:19,800
中文字幕
thereby inducing a segmentation fault, and buffer heap overflow

2554
02:01:19,800 --> 02:01:21,760
中文字幕
is in the reverse direction, and these are more

2555
02:01:21,760 --> 02:01:26,620
中文字幕
generally known as buffer overflows, and we'll see more of these in the weeks

2556
02:01:26,620 --> 02:01:27,340
中文字幕
to come.

2557
02:01:27,340 --> 02:01:29,710
中文字幕
But now that we have the ability to discuss pointers,

2558
02:01:29,710 --> 02:01:33,490
中文字幕
let's introduce one final feature and then a familiar face.

2559
02:01:33,490 --> 02:01:38,440
中文字幕
So it turns out that you can actually come up with your own custom variables

2560
02:01:38,440 --> 02:01:42,370
中文字幕
kind of like we did with string, but even more sophisticated than that.

2561
02:01:42,370 --> 02:01:46,120
中文字幕
For instance, if I wanted to implement a program that

2562
02:01:46,120 --> 02:01:49,480
中文字幕
involves multiple students, I might do something like this.

2563
02:01:49,480 --> 02:01:52,810
中文字幕
Ask the user what is the enrollment in a class, then go ahead

2564
02:01:52,810 --> 02:01:55,130
中文字幕
and give myself an array of strings, a.k.a.

2565
02:01:55,130 --> 02:01:59,650
中文字幕
char*s today of that size, and then I could also have another array of dorms.

2566
02:01:59,650 --> 02:02:03,240
中文字幕
And I could have two arrays containing one for the students' names,

2567
02:02:03,240 --> 02:02:05,990
中文字幕
one for the students' dorms, and I can keep track of other things.

2568
02:02:05,990 --> 02:02:08,900
中文字幕
Another array for emails, another array for phone numbers--

2569
02:02:08,900 --> 02:02:11,230
中文字幕
but this gets messy quickly, because you can imagine,

2570
02:02:11,230 --> 02:02:15,430
中文字幕
if I need names and dorms and emails and phones,

2571
02:02:15,430 --> 02:02:17,710
中文字幕
that starts to become a lot of copy-paste.

2572
02:02:17,710 --> 02:02:20,800
中文字幕
And I just have this design where I have lots and lots of arrays

2573
02:02:20,800 --> 02:02:24,160
中文字幕
where each bracket location-- like bracket 0, bracket 1

2574
02:02:24,160 --> 02:02:28,420
中文字幕
presumably refers to the same student across all of these arrays, like mmm!

2575
02:02:28,420 --> 02:02:30,370
中文字幕
Messy, messy, messy design.

2576
02:02:30,370 --> 02:02:32,350
中文字幕
So with a wave of my hand, let me actually

2577
02:02:32,350 --> 02:02:36,040
中文字幕
fix that immediate problem out of the gate by introducing a new feature.

2578
02:02:36,040 --> 02:02:38,170
中文字幕
I can invent my own data types.

2579
02:02:38,170 --> 02:02:40,240
中文字幕
Let me just go ahead and declare an array

2580
02:02:40,240 --> 02:02:46,480
中文字幕
called students with this many students, but of data type student.

2581
02:02:46,480 --> 02:02:51,400
中文字幕
C comes with float, bool, char, int, not string, and definitely not student.

2582
02:02:51,400 --> 02:02:54,020
中文字幕
So you can make your own custom data types,

2583
02:02:54,020 --> 02:02:57,160
中文字幕
and you can put them in your own header files, which we've not done either.

2584
02:02:57,160 --> 02:03:00,870
中文字幕
But I can look, and you'll see more of this in the next problem set.

2585
02:03:00,870 --> 02:03:02,620
中文字幕
So not to worry if this feels quite brief,

2586
02:03:02,620 --> 02:03:04,800
中文字幕
it's just meant to be a teaser here.

2587
02:03:04,800 --> 02:03:09,580
中文字幕
And struct.h is how you declare or define your own type.

2588
02:03:09,580 --> 02:03:13,690
中文字幕
The keyword is literally typedef struct for structure, or data structure

2589
02:03:13,690 --> 02:03:14,740
中文字幕
to be more complete.

2590
02:03:14,740 --> 02:03:18,430
中文字幕
The name of the data structure comes at the end after some curly braces.

2591
02:03:18,430 --> 02:03:20,620
中文字幕
And then inside the curly braces you just specify,

2592
02:03:20,620 --> 02:03:22,280
中文字幕
well what do you want a student to have?

2593
02:03:22,280 --> 02:03:25,690
中文字幕
I want them to have a name, a dorm, maybe a phone number, maybe

2594
02:03:25,690 --> 02:03:27,140
中文字幕
an email address, anything I want.

2595
02:03:27,140 --> 02:03:28,510
中文字幕
I can just add here.

2596
02:03:28,510 --> 02:03:34,690
中文字幕
So that now in my actual code, I can have an array of actual students,

2597
02:03:34,690 --> 02:03:37,960
中文字幕
and I can just access them with this new notation like this.

2598
02:03:37,960 --> 02:03:40,990
中文字幕
You know that you can index into an array with bracket notation.

2599
02:03:40,990 --> 02:03:45,070
中文字幕
What you didn't know until now, perhaps, is that if at that location

2600
02:03:45,070 --> 02:03:46,900
中文字幕
is a structure, a.k.a.

2601
02:03:46,900 --> 02:03:51,100
中文字幕
struct, you can get at the name, the dorm, or the phone, or the email,

2602
02:03:51,100 --> 02:03:54,160
中文字幕
or anything else there just by using a dot-notation, which is

2603
02:03:54,160 --> 02:03:56,320
中文字幕
our last piece of new syntax for today.

2604
02:03:56,320 --> 02:03:58,040
中文字幕
Everything else is the same.

2605
02:03:58,040 --> 02:04:01,450
中文字幕
I can write a program that says so and so is in such and such a dorm

2606
02:04:01,450 --> 02:04:05,410
中文字幕
by just saying get the i-th student's name and the i-th student's dorm.

2607
02:04:05,410 --> 02:04:09,190
中文字幕
And I can be even fancier, and if I don't want to just print those values,

2608
02:04:09,190 --> 02:04:13,060
中文字幕
I can even, now, that I see no understand pointers--

2609
02:04:13,060 --> 02:04:15,340
中文字幕
or I've seen pointers and we'll soon understand them

2610
02:04:15,340 --> 02:04:19,090
中文字幕
by way of problem sets and practice, I can actually do this.

2611
02:04:19,090 --> 02:04:21,760
中文字幕
This is just a little sneak preview of a line of code

2612
02:04:21,760 --> 02:04:23,920
中文字幕
that uses a new function called fopen.

2613
02:04:23,920 --> 02:04:27,130
中文字幕
fopen this file open, and it takes in the name of the file to open.

2614
02:04:27,130 --> 02:04:29,800
中文字幕
You might know of CSV files, they're like simple spreadsheets,

2615
02:04:29,800 --> 02:04:31,660
中文字幕
comma separated values.

2616
02:04:31,660 --> 02:04:33,610
中文字幕
And quote-unquote "w" means write.

2617
02:04:33,610 --> 02:04:37,150
中文字幕
So this says open the file called students.csv in write mode,

2618
02:04:37,150 --> 02:04:38,320
中文字幕
so I can write to this file.

2619
02:04:38,320 --> 02:04:40,840
中文字幕
Because in this example, as you'll see in the days to come,

2620
02:04:40,840 --> 02:04:42,800
中文字幕
I want to write out to a file.

2621
02:04:42,800 --> 02:04:45,940
中文字幕
But it turns out to use files, I need to know what a pointer is,

2622
02:04:45,940 --> 02:04:47,740
中文字幕
and it's a little weird that it's all caps,

2623
02:04:47,740 --> 02:04:51,770
中文字幕
but there is a data type in C called "file," and it's a pointer.

2624
02:04:51,770 --> 02:04:54,650
中文字幕
So long story short, what you're going to see in the next problem set

2625
02:04:54,650 --> 02:04:56,950
中文字幕
as we explore the world of forensics is the ability

2626
02:04:56,950 --> 02:05:00,260
中文字幕
using pointers and a few new functions to open files and get back

2627
02:05:00,260 --> 02:05:04,490
中文字幕
the address of that file in memory so that you can go to that address,

2628
02:05:04,490 --> 02:05:07,430
中文字幕
change the contents of a file, and save it back out.

2629
02:05:07,430 --> 02:05:10,640
中文字幕
All of us take for granted these days that you can go to File, Open and File,

2630
02:05:10,640 --> 02:05:13,270
中文字幕
Save, but what's actually happening, pointers are involved,

2631
02:05:13,270 --> 02:05:15,440
中文字幕
stuff's getting loaded into memory, and the computer

2632
02:05:15,440 --> 02:05:17,960
中文字幕
is dereferencing or going to those addresses

2633
02:05:17,960 --> 02:05:20,720
中文字幕
and changing what's at those locations in memory.

2634
02:05:20,720 --> 02:05:22,140
中文字幕
Now why might you want to do this?

2635
02:05:22,140 --> 02:05:23,600
中文字幕
Well here, of course, is Zamila-- you might

2636
02:05:23,600 --> 02:05:26,060
中文字幕
recall from some of the problem sets and the walkthroughs.

2637
02:05:26,060 --> 02:05:30,320
中文字幕
Turns out we could try to enhance this picture of her by zooming in,

2638
02:05:30,320 --> 02:05:33,660
中文字幕
and here's about as much fidelity as it is in her eyes.

2639
02:05:33,660 --> 02:05:38,090
中文字幕
Like I do not see the glint of any criminal's logo

2640
02:05:38,090 --> 02:05:40,730
中文字幕
on his or her jacket in the glint of Zamila's eyes.

2641
02:05:40,730 --> 02:05:43,580
中文字幕
If you zoom in on an image, and an image, recall, from week 0

2642
02:05:43,580 --> 02:05:47,580
中文字幕
is just a grid of pixels or dots, that's all you get.

2643
02:05:47,580 --> 02:05:50,690
中文字幕
And you can maybe smooth it out a little bit or clean up the colors,

2644
02:05:50,690 --> 02:05:53,390
中文字幕
but you can't just "enhance," quote-unquote,

2645
02:05:53,390 --> 02:05:55,760
中文字幕
and see more of the glint in Zamila's eye,

2646
02:05:55,760 --> 02:05:59,600
中文字幕
because an image at the end of the day is just a bitmap, a map--

2647
02:05:59,600 --> 02:06:01,670
中文字幕
top-down, left-right-- of pixels.

2648
02:06:01,670 --> 02:06:03,140
中文字幕
For instance, here's a smiley face.

2649
02:06:03,140 --> 02:06:06,650
中文字幕
If you kind of take a look back and you can kind of see a black smiley

2650
02:06:06,650 --> 02:06:08,390
中文字幕
face against a white backdrop.

2651
02:06:08,390 --> 02:06:11,390
中文字幕
And if we just decide as humans, let's represent white dots

2652
02:06:11,390 --> 02:06:15,350
中文字幕
with 1's and black dots with 0's, this might be what's in the file,

2653
02:06:15,350 --> 02:06:16,790
中文字幕
this is what the human sees.

2654
02:06:16,790 --> 02:06:21,140
中文字幕
So if we have the ability to open that from a file, store it in memory,

2655
02:06:21,140 --> 02:06:24,420
中文字幕
and then using pointers go to those locations in memory,

2656
02:06:24,420 --> 02:06:27,800
中文字幕
we can even change the smiley face to an unhappy face, for instance, or color it

2657
02:06:27,800 --> 02:06:29,990
中文字幕
or do any number of things to it.

2658
02:06:29,990 --> 02:06:32,660
中文字幕
Now at quick glance, there's a lot going on in files,

2659
02:06:32,660 --> 02:06:37,010
中文字幕
because what a file is is a set of conventions that humans decided

2660
02:06:37,010 --> 02:06:40,130
中文字幕
on where humans years ago just decided in a bitmap file,

2661
02:06:40,130 --> 02:06:44,960
中文字幕
BMP file-- so an older but still popular file format for images, humans

2662
02:06:44,960 --> 02:06:48,170
中文字幕
just decided that, like, we're going to put a bunch of special values

2663
02:06:48,170 --> 02:06:50,150
中文字幕
at the first bytes of the file, then some more

2664
02:06:50,150 --> 02:06:55,990
中文字幕
special values than the actual RGB pixels in the rest of the file.

2665
02:06:55,990 --> 02:06:58,040
中文字幕
So this is meant to look cryptic at first glance,

2666
02:06:58,040 --> 02:07:00,530
中文字幕
and the next homework assignment will walk you through this,

2667
02:07:00,530 --> 02:07:04,340
中文字幕
but all it is is a convention of what the 0's and 1's mean

2668
02:07:04,340 --> 02:07:05,780
中文字幕
in these different locations.

2669
02:07:05,780 --> 02:07:08,460
中文字幕
And indeed, the challenge ahead is going to be to do a number of things.

2670
02:07:08,460 --> 02:07:10,190
中文字幕
One is to first and foremost figure out--

2671
02:07:10,190 --> 02:07:10,990
中文字幕
who done it?

2672
02:07:10,990 --> 02:07:14,360
中文字幕
A sort of murder mystery in which there's a clue hidden in an image,

2673
02:07:14,360 --> 02:07:16,310
中文字幕
but an image that's a little noisy and you're

2674
02:07:16,310 --> 02:07:18,850
中文字幕
going to have to figure out what secret messages in the image

2675
02:07:18,850 --> 02:07:22,490
中文字幕
by loading that image in, tweaking it, putting a sort of red filter

2676
02:07:22,490 --> 02:07:25,940
中文字幕
on top of it and seeing the secret message, but all digitally; two,

2677
02:07:25,940 --> 02:07:29,800
中文字幕
actually resizing images and taking this many pixels in this big

2678
02:07:29,800 --> 02:07:32,130
中文字幕
of a smiley face or something else and making it bigger,

2679
02:07:32,130 --> 02:07:34,400
中文字幕
or if more comfortable, making it even smaller

2680
02:07:34,400 --> 02:07:36,680
中文字幕
and figuring out how to make that workout;

2681
02:07:36,680 --> 02:07:39,980
中文字幕
and then lastly, we've been taking some photographs of all CS50 staff

2682
02:07:39,980 --> 02:07:41,450
中文字幕
in Cambridge and New Haven.

2683
02:07:41,450 --> 02:07:45,440
中文字幕
Unfortunately we accidentally corrupted or lost the memory card,

2684
02:07:45,440 --> 02:07:49,060
中文字幕
but we made a forensic image of it, a copy of all of the 0's and 1's with all

2685
02:07:49,060 --> 02:07:50,900
中文字幕
of the staff photos, and we're going to need

2686
02:07:50,900 --> 02:07:53,880
中文字幕
you to write code that actually recovers all of the JPEGs

2687
02:07:53,880 --> 02:07:57,640
中文字幕
or photographs from that digital card by opening a file,

2688
02:07:57,640 --> 02:08:00,020
中文字幕
reading in those 0's and 1's, understanding what they are

2689
02:08:00,020 --> 02:08:01,720
中文字幕
and where they are, and just writing them

2690
02:08:01,720 --> 02:08:05,210
中文字幕
back out to disk using functions we'll introduce you to in the problem

2691
02:08:05,210 --> 02:08:06,080
中文字幕
set itself.

2692
02:08:06,080 --> 02:08:09,350
中文字幕
But of course, all of this takes for granted that we can do this,

2693
02:08:09,350 --> 02:08:10,590
中文字幕
and you can only do so much.

2694
02:08:10,590 --> 02:08:13,460
中文字幕
And indeed, this week is as much about solving those problems

2695
02:08:13,460 --> 02:08:16,200
中文字幕
as it is realizing the limitations of computers,

2696
02:08:16,200 --> 02:08:19,340
中文字幕
and so we thought we'd end with the final few seconds of this very

2697
02:08:19,340 --> 02:08:21,940
中文字幕
real example from Futurama.

2698
02:08:21,940 --> 02:08:22,720
中文字幕
[VIDEO PLAYBACK]

2699
02:08:22,720 --> 02:08:24,360
中文字幕
- Magnify that death sphere.

2700
02:08:27,000 --> 02:08:28,450
中文字幕
Why is it still blurry?

2701
02:08:28,450 --> 02:08:30,450
中文字幕
- That's all the resolution we have.

2702
02:08:30,450 --> 02:08:32,790
中文字幕
Making it bigger doesn't make it clearer.

2703
02:08:32,790 --> 02:08:34,500
中文字幕
- It does on CSI Miami.

2704
02:08:34,500 --> 02:08:35,170
中文字幕
- Ugh.

2705
02:08:35,760 --> 02:08:38,400
中文字幕
And that's it for CS50, we'll see you next time.

